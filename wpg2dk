#!/usr/bin/perl

#
# wpg2dk - migrate from Windows Photo Gallery to digiKam.
#

use strict;
use warnings                    qw( FATAL all );

use DBI                         qw();
use DBD::SQLite::Constants      qw( :file_open );
use Data::Dumper                qw( Dumper );
use File::Spec::Functions       qw( catfile );
use Getopt::Long                qw( GetOptions );
use Image::ExifTool             qw();

$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse    = 1;

# media object message IDs
use constant MSGID_DUP_OBJID         => "dup_objid";
use constant MSGID_NULL_ATTRIBUTES   => "null_attributes";
use constant MSGID_INVALID_REGION    => "invalid_region";
use constant MSGID_UNDEFINED_PERSON  => "undefined_person";
use constant MSGID_DUBIOUS_PERSON    => "dubious_person";
use constant MSGID_INVALID_TAG       => "invalid_tag";
use constant MSGID_DUBIOUS_TAG       => "dubious_tag";
use constant MSGID_INVALID_GEOTAG    => "invalid_geotag";
use constant MSGID_DUBIOUS_GEOTAG    => "dubious_geotag";
use constant MSGID_DUP_GEOTAG        => "dup_geotag";
use constant MSGID_IGNORED_FILE      => "ignored_file";
use constant MSGID_UNMAPPED_FILE     => "unmapped_file";
use constant MSGID_FILE_MISSING      => "file_missing";
use constant MSGID_IGNORED_XFILE     => "ignored_xfile";
use constant MSGID_UNMAPPED_XFILE    => "unmapped_xfile";
use constant MSGID_XFILE_EXISTS      => "xfile_exists";
use constant MSGID_EXIFTOOL_WARNINGS => "exiftool_warnings";
use constant MSGID_EXIFTOOL_ERRORS   => "exiftool_errors";

my @MESSAGE_IDS = (
  MSGID_DUP_OBJID,
  MSGID_NULL_ATTRIBUTES,
  MSGID_INVALID_REGION,
  MSGID_UNDEFINED_PERSON,
  MSGID_DUBIOUS_PERSON,
  MSGID_INVALID_TAG,
  MSGID_DUBIOUS_TAG,
  MSGID_INVALID_GEOTAG,
  MSGID_DUBIOUS_GEOTAG,
  MSGID_DUP_GEOTAG,
  MSGID_IGNORED_FILE,
  MSGID_UNMAPPED_FILE,
  MSGID_FILE_MISSING,
  MSGID_IGNORED_XFILE,
  MSGID_UNMAPPED_XFILE,
  MSGID_XFILE_EXISTS,
  MSGID_EXIFTOOL_WARNINGS,
  MSGID_EXIFTOOL_ERRORS,
);

# tag tree node message IDs
use constant TAGMSGID_DUP_ID       => "dup_id";
use constant TAGMSGID_UNDEF_NAME   => "undef_name";
use constant TAGMSGID_UNDEF_PID    => "undef_pid";
use constant TAGMSGID_MISSING_PID  => "missing_pid";
use constant TAGMSGID_MISSING_ROOT => "missing_root";

# people message IDs
use constant PPLMSGID_DUP_ID       => "dup_id";
use constant PPLMSGID_UNDEF_NAME   => "undef_name";

my %ACTIONS = (
  'list'    => 1,
  'dump'    => 1,
  'listerr' => 1,
  'check'   => 1,
  'extract' => 1,
);

#{{{ auxilliary functions

sub error
{
  print STDERR ( @_, "\n" );
  exit( 1 );
}

sub usage
{
  print STDERR ( @_, "\n" );
  exit( 2 );
}

# convert the specified structure to a string
sub s2s
{
  local $Data::Dumper::Indent = 0;
  return Dumper( $_[0] );
}

# brush up the specified error message
sub bue
{
  my $error = $_[0];
  $error =~ s/^\s+//;
  $error =~ s/\s+$//;
  $error =~ s/\s+/ /g;
  $error =~ s/ at .*? line \d+\.$//;
  return lc( $error );
}

#}}}

#{{{ cavmap

# converts and verifies the specified map
sub cavmap
{
  for my $me ( @_ ) {
    my $fn = "";
    if ( $me =~ /^s\{.*\}\{.*\}[a-z]*$/m ) {
      if ( ! defined( do { package _wpg2dk; eval( "\$fn =~ $me" ) } ) ) {
        usage( "Invalid map entry \"$me\" (", bue( $@ ), ")" );
      }
    }
    elsif ( $me =~ /^(.*?)(?:=(.*))?$/m ) {
      my ( $search, $repl ) = ( $1, $2 );
      $repl //= "";
      if ( ! defined( do { package _wpg2dk; eval( '$fn =~ s/$search/$repl/g' ) } ) ) {
        usage( "Invalid map entry \"$me\" (", bue( $@ ), ")" );
      }
      $me = [ $me, $search, $repl ];
    }
    else {
      usage( "Invalid map entry \"$me\"" );
    }
  }
}

#}}}

#{{{ aplmap

# applies the specified map to the specified file name
sub aplmap
{
  my $fn = shift( @_ );
  for my $me ( @_ ) {
    if ( ! ref( $me ) ) {
      if ( ! defined( do { package _wpg2dk; eval( "\$fn =~ $me" ) } ) ) {
        error( "Cannot apply map entry \"$me\" to \"$fn\" (", bue( $@ ), ")" );
      }
    }
    else {
      my ( $me, $search, $repl ) = @{$me};
      if ( ! defined( do { package _wpg2dk; eval( '$fn =~ s/$search/$repl/g' ) } ) ) {
        error( "Cannot apply map entry \"$me\" to \"$fn\" (", bue( $@ ), ")" );
      }
    }
  }
  return $fn;
}

#}}}

#{{{ catnodes, readtree

sub catnodes
{
  my ( $id, $nodes ) = @_;

  my $node = $nodes->{$id}->[0];
  if ( exists( $node->{'done'} ) ) {
    # no-op
  }
  elsif ( (! defined( $node->{'pid'} )) ) {
    $node->{'done'} = 1;
    push( @{$node->{'warnings'}},
          [ TAGMSGID_UNDEF_PID, $node ] );
  }
  elsif ( ($node->{'pid'} == 0) ) {
    $node->{'done'} = 1;
  }
  elsif ( (! exists( $nodes->{$node->{'pid'}} )) ) {
    $node->{'done'} = 1;
    push( @{$node->{'warnings'}},
          [ TAGMSGID_MISSING_PID, $node ] );
  }
  else {
    $node->{'done'} = 1;
    catnodes( $node->{'pid'}, $nodes );
    push( @{$nodes->{$id}}, @{$nodes->{$node->{'pid'}}} );
  }
}

# reads the tree of (geo)tags from the specified statement handle
# and returns it as a hash mapping tag ids to arrays consisting
# of tag nodes
#
#   {
#      <id> => [ <tag-node-0>, ..., <tag-node-n> ],
#      ...,
#   }
#
# where tag node 0 has tag id <id> and tag node i+1 is the parent
# node of tag node i.
sub readtree
{
  my ( $sth ) = @_;

  my %nodes = ();
  while ( my $node = $sth->fetchrow_hashref() ) {
    my $id = $node->{'id'};
    $node->{'warnings'} = [];

    if ( (! defined( $id )) || ($id == 0) ) {
      warn( "Cannot process undefined or zero node ID (", s2s( $node ), ")" );
      next;
    }

    if ( exists( $nodes{$id} ) ) {
      push( @{$nodes{$id}->[0]->{'warnings'}},
            [ TAGMSGID_DUP_ID, $node ] );
      next;
    }

    if ( (! defined( $node->{'name'} )) ||
         (length( $node->{'name'} ) == 0) ) {
      $node->{'name'} = "wpg2dk-generated-#$id";
      push( @{$node->{'warnings'}},
            [ TAGMSGID_UNDEF_NAME, $node ] );
    }

    $nodes{$id} = [ $node ];
  }

  # concatenate tag nodes along their path to root
  for my $id ( keys( %nodes ) ) {
    catnodes( $id, \%nodes );
  }

  # detect and flag rootless tag nodes (which can result from our
  # node loop detection)
  for my $nodes ( values( %nodes ) ) {
    if ( (defined( $nodes->[-1]->{'pid'} )) &&
         ($nodes->[-1]->{'pid'} != 0) ) {
      push( @{$nodes->[-1]->{'warnings'}},
            [ TAGMSGID_MISSING_ROOT, $nodes->[-1] ] );
    }
  }

  return \%nodes;
}

#}}}

#{{{ object error handling

# adds the specified warning to the specified media object
sub addwarning
{
  if ( $main::relax_obj_warnings ) {
    my $obj     = shift( @_ );
    my $msgid   = shift( @_ );
    my $message = [ $msgid, @_ ];
    push( @{$obj->{'warnings'}}, $message );
  }
  else {
    adderror( @_ );
  }
}

my %errobjs = ();
my %errids  = map { ($_ => []) } @MESSAGE_IDS;

# adds the specified error to the specified media object and
# updates global variables on erroneous objects
sub adderror
{
  my $obj     = shift( @_ );
  my $msgid   = shift( @_ );
  my $message = [ $msgid, @_ ];
  push( @{$obj->{'errors'}}, $message );
  $errobjs{$obj} = 1;
  push( @{$errids{$msgid}}, $obj );
}

# returns whether to continue processing the specified media
# object
sub continuep
{
  return scalar( @{$_[0]->{'errors'}} ) > 0 ? 0 : 1;
}

#}}}

#{{{ process commandline parameters

my $action = undef();
if ( scalar( @ARGV ) > 0 ) {
  $action = shift( @ARGV );
}
else {
  usage( "No action specified." );
}

if ( ! exists( $ACTIONS{$action} ) ) {
  usage( "Invalid action \"$action\" specified." );
}

my  $force              = 0;
our $relax_obj_warnings = 1;
my  @mmap               = ();
my  @xmap               = ();
{
  my $error = undef();
  local $SIG{'__WARN__'} = sub { $error = bue( $_[0] ) };
  if ( ! GetOptions( "force"               => \$force,
                     "relax_obj_warnings!" => \$relax_obj_warnings,
                     "mmap=s"              => \@mmap,
                     "xmap=s"              => \@xmap ) ) {
    usage( "Invalid commandline parameters specified ($error)." );
  }
}

# default XMP map
@xmap = 's{$}{.wpg2dk.xmp}' unless ( scalar( @xmap ) );

# convert and verify maps
cavmap( @mmap );
cavmap( @xmap );

my $dbn = undef();
if ( scalar( @ARGV ) > 0 ) {
  $dbn = shift( @ARGV );
}
else {
  usage( "No database name specified." );
}

my @globs  = ();
my @msgids = ();
if ( $action ne "listerr" ) {
  @globs  = @ARGV;
  @msgids = ();
}
else {
  @globs  = ();
  @msgids = @ARGV;

  for my $msgid ( @msgids ) {
    if ( ! grep { $_ eq $msgid } @MESSAGE_IDS ) {
      usage( "Invalid message ID \"$msgid\" specified." );
    }
  }
}

#}}}

my $exiftool = new Image::ExifTool();

my @errors   = ();
my @warnings = ();
$SIG{'__WARN__'} = sub { push( @warnings, $_[0] ) };

eval {
  my $dbh = DBI->connect( "dbi:SQLite:dbname=$dbn", undef(), undef(),
                          {
                            'sqlite_open_flags' => SQLITE_OPEN_READONLY,
                            'RaiseError'        => 1,
                          } );
  my $sth = undef();

  # read objects
  $sth = $dbh->prepare( q{
    select    o.objectid   objid,
              o.syncstatus status,
              o.title      title,
              o.rating     rating,
              o.flagged    flag,
              v.volumeid   volid,
              p.path       pn,
              o.filename   fn
    from      tblobject o
    left join tblpath   p on o.filepathid = p.pathid
    left join tblvolume v on p.volumeid   = v.volumeid
    order by  volid nulls first, pn nulls first, fn nulls first
  } );

  $sth->execute();

  my %objs = ();
  my @objs = ();
  while ( my $obj = $sth->fetchrow_hashref() ) {
    $obj->{'errors'}   = [];
    $obj->{'warnings'} = [];

    my $objid = $obj->{'objid'};

    if ( (defined( $objid )) &&
         (! exists( $objs{$objid} )) ) {
      $objs{$objid} = $obj;
    }
    elsif ( (defined( $objid )) ) {
      addwarning( $obj, MSGID_DUP_OBJID, $objs{$objid} );
    }

    $obj->{'people'} = [];
    $obj->{'geotag'} = undef();
    $obj->{'tags'}   = [];

    push( @objs, $obj );
  }

  # handle undefined attributes appropriately
  for my $obj ( @objs ) {
    if ( defined( $obj->{'objid'} ) &&
         defined( $obj->{'volid'} ) &&
         defined( $obj->{'pn'} )    &&
         defined( $obj->{'fn'} ) ) {
      # no-op
    }
    else {
      adderror( $obj, MSGID_NULL_ATTRIBUTES, $obj );
    }

    $obj->{'status'} //= 0;
    $obj->{'title'}  //= "";
    $obj->{'rating'} //= 0;
    $obj->{'flag'}   //= 0;
  }

  # read persons
  $sth = $dbh->prepare( q{
    select personid pid,
           name     name
    from   tblperson
  } );
  $sth->execute();
  my %persons = ();
  while ( my $person = $sth->fetchrow_hashref() ) {
    my $pid = $person->{'pid'};
    $person->{'warnings'} = [];

    if ( (! defined( $pid )) || ($pid == 0) ) {
      warn( "Cannot process undefined or invalid person ID of person (", s2s( $person ), ").\n" );
      next;
    }

    if ( exists( $persons{$pid} ) ) {
      push( @{$persons{$pid}->{'warnings'}},
            [ PPLMSGID_DUP_ID, $person ] );
      next;
    }

    if ( (! defined( $person->{'name'} )) ||
         (length( $person->{'name'} ) == 0) ) {
      $person->{'name'} = "wpg2dk-generated-#$pid";
      push( @{$person->{'warnings'}},
            [ PPLMSGID_UNDEF_NAME, $person ] );
    }

    $persons{$pid} = $person;
  }

  # read regions and attach them to objects.  Force lowercase
  # column names.
  $sth = $dbh->prepare( q{
    select objectid objid,
           personid pid,
           left     "left",
           top      top,
           width    width,
           height   height
    from   tblregion
  } );
  $sth->execute();
  while ( my $region = $sth->fetchrow_hashref() ) {
    my ( $oid, $pid ) = @{$region}{'objid', 'pid'};

    if ( (! defined( $oid )) ||
         (! exists( $objs{$oid} )) ) {
      warn( "Cannot process undefined or invalid object ID of region (", s2s( $region ), ").\n" );
    }
    elsif ( (! defined( $pid )) ||
            (! defined( $region->{'left'} ))  ||
            (! defined( $region->{'top'} ))   ||
            (! defined( $region->{'width'} )) ||
            (! defined( $region->{'height'} )) ) {
      addwarning( $objs{$oid}, MSGID_INVALID_REGION, $region );
    }
    elsif ( ($pid != 0) &&
            (! exists( $persons{$pid} )) ) {
      $region->{'name'} = "wpg2dk-generated-#$pid";
      push( @{$objs{$oid}->{'people'}}, $region );
      addwarning( $objs{$oid}, MSGID_UNDEFINED_PERSON, $region );
    }
    elsif ( ($pid == 0) ) {
      $region->{'name'} = undef();
      push( @{$objs{$oid}->{'people'}}, $region );
    }
    else {
      $region->{'name'} = $persons{$pid}->{'name'};
      push( @{$objs{$oid}->{'people'}}, $region );
      if ( scalar( @{$persons{$pid}->{'warnings'}} ) > 0 ) {
        addwarning( $objs{$oid}, MSGID_DUBIOUS_PERSON, $persons{$pid} );
      }
    }
  }

  # read geotags
  $sth = $dbh->prepare( q{
    select locationid       id,
           locationname     name,
           locationlat      lat,
           locationlong     long,
           locationparentid pid
    from   tbllocation
  } );
  $sth->execute();
  my $geotags = readtree( $sth );

  # attach geotags to objects
  $sth = $dbh->prepare( q{
    select locationid       id,
           objectid         oid
    from   tblocationUsage
  } );
  $sth->execute();
  while ( my @row = $sth->fetchrow_array() ) {
    my ( $id, $oid ) = @row;

    if ( (! defined( $oid )) ||
         (! exists( $objs{$oid} )) ) {
      warn( "Cannot process undefined or invalid object ID of geotag (", s2s( \@row ), ").\n" );
    }
    elsif ( (! defined( $id )) ||
            (! exists( $geotags->{$id} )) ) {
      addwarning( $objs{$oid}, MSGID_INVALID_GEOTAG, $id );
    }
    elsif ( (defined( $objs{$oid}->{'geotag'} )) ) {
      addwarning( $objs{$oid}, MSGID_DUP_GEOTAG, $geotags->{$id} );
    }
    else {
      $objs{$oid}->{'geotag'} = $geotags->{$id};
      if ( grep( scalar( @{$_->{'warnings'}} ), @{$geotags->{$id}} ) ) {
        addwarning( $objs{$oid}, MSGID_DUBIOUS_GEOTAG, $geotags->{$id} );
      }
    }
  }

  # read tags
  $sth = $dbh->prepare( q{
    select labelid       id,
           labelname     name,
           parentlabelid pid
    from   tbllabel
  } );
  $sth->execute();
  my $tags = readtree( $sth );

  # attach tags to objects
  $sth = $dbh->prepare( q{
    select labelid       id,
           objectid      oid
    from   tbllabelusage
  } );
  $sth->execute();
  while ( my @row = $sth->fetchrow_array() ) {
    my ( $id, $oid ) = @row;

    if ( (! defined( $oid )) ||
         (! exists( $objs{$oid} )) ) {
      warn( "Cannot process undefined or invalid object ID of tag (", s2s( \@row ), ").\n" );
    }
    elsif ( (! defined( $id )) ||
            (! exists( $tags->{$id} )) ) {
      addwarning( $objs{$oid}, MSGID_INVALID_TAG, $id );
    }
    else {
      push( @{$objs{$oid}->{'tags'}}, $tags->{$id} );
      if ( grep( scalar( @{$_->{'warnings'}} ), @{$tags->{$id}} ) ) {
        addwarning( $objs{$oid}, MSGID_DUBIOUS_TAG, $tags->{$id} );
      }
    }
  }

  # map file names and look up media metadata
  for my $obj ( @objs ) {
    if ( continuep( $obj ) ) {
      # determine original and mapped absolute media file name
      my $fnao = $obj->{'volid'} . ":" .
                 catfile( split( /\\/, $obj->{'pn'} ), $obj->{'fn'} );
      my $fna  = aplmap( $fnao, @mmap );

      # likewise for the intermediate XMP file name
      my $xnao = $fna;
      my $xna  = aplmap( $fna, @xmap );

      $obj->{'fnao'} = $fnao;
      $obj->{'fna'}  = $fna;
      $obj->{'xnao'} = $xnao;
      $obj->{'xna'}  = $xna;

      if ( length( $fna ) == 0 ) {
        adderror( $obj, MSGID_IGNORED_FILE, $fnao );
      }
      elsif ( $fna eq $fnao ) {
        adderror( $obj, MSGID_UNMAPPED_FILE, $fnao );
      }
      elsif ( ! -f $fna ) {
        adderror( $obj, MSGID_FILE_MISSING, $fna, $fnao );
      }
    }

    if ( continuep( $obj ) ) {
      my $xnao = $obj->{'xnao'};
      my $xna  = $obj->{'xna'};

      if ( length( $xna ) == 0 ) {
        invalidate( $obj, MSGID_IGNORED_XFILE );
      }
      elsif ( $xna eq $xnao ) {
        invalidate( $obj, MSGID_UNMAPPED_XFILE );
      }
      elsif ( (-e $xna) && (! $force) ) {
        invalidate( $obj, MSGID_XFILE_EXISTS );
      }
    }

    if ( continuep( $obj ) ) {
      my $fna = $obj->{'fna'};

      # determine media file metadata
      my $info = $exiftool->ImageInfo( $fna,
                                       [ 'File::MimeType',
                                         'EXIF:Orientation',
                                         'ExifTool:Warning',
                                         'ExifTool:Error' ],
                                       { 'PrintConv' => 0 } );

      $obj->{'mime'}   = $info->{'MIMEType'};
      $obj->{'xfornt'} = $info->{'Orientation'};

      # convert ExifTool warnings and errors into media object
      # warnings and errors, respectively
      my @xfwarnings = ();
      my @xferrors   = ();
      for my $tag ( sort( keys( %{$info} ) ) ) {
        next if ( ($tag =~ /^Warning\b/) &&
                  (defined( $info->{$tag} )) &&
                  (lc( $info->{$tag}) eq "[minor] fixed incorrect uri for xmlns:microsoftphoto") );
        push( @xfwarnings, bue( $info->{$tag} ) ) if ( $tag =~ /^Warning\b/ );
        push( @xferrors,   bue( $info->{$tag} ) ) if ( $tag =~ /^Error\b/ );
      }
      if ( scalar( @xfwarnings ) > 0 ) {
        addwarning( $obj, MSGID_EXIFTOOL_WARNINGS, @xfwarnings );
      }
      if ( scalar( @xferrors ) > 0 ) {
        adderror( $obj, MSGID_EXIFTOOL_ERRORS, @xferrors );
      }
    }
  }

  if ( $action eq "dump" ) {
    for my $obj ( @objs ) {
      print( Dumper( $obj ) );
    }
  }

  if ( $action eq "listerr" ) {
    @msgids = @MESSAGE_IDS if ( scalar( @msgids ) == 0 );

    for my $msgid ( @msgids ) {
      if ( scalar( @{$errids{$msgid}} ) > 0 ) {
        print( "$msgid\n" );
        for my $io ( @{$errids{$msgid}} ) {
          if ( ($msgid eq MSGID_NULL_ATTRIBUTES) ) {
            printf( "  %5d %s:%s\\%s\n",
                    $io->{'objid'} // "NULL",
                    $io->{'volid'} // "NULL",
                    $io->{'pn'}    // "NULL",
                    $io->{'fn'}    // "NULL" );
          }
          elsif ( ($msgid eq MSGID_IGNORED_FILE) ) {
            print( "  $io->{'fnao'}\n" );
          }
          elsif ( ($msgid eq MSGID_UNMAPPED_FILE) ) {
            print( "  $io->{'fnao'}\n" );
          }
          elsif ( ($msgid eq MSGID_FILE_MISSING) ) {
            print( "  $io->{'fnao'}\n" );
            print( "  => $io->{'fna'}\n" );
          }
          elsif ( ($msgid eq MSGID_IGNORED_XFILE) ) {
            print( "  $io->{'xnao'}\n" );
          }
          elsif ( ($msgid eq MSGID_UNMAPPED_XFILE) ) {
            print( "  $io->{'xnao'}\n" );
          }
          elsif ( ($msgid eq MSGID_XFILE_EXISTS) ) {
            print( "  $io->{'xnao'}\n" );
            print( "  => $io->{'xna'}\n" );
          }
          elsif ( ($msgid eq MSGID_EXIFTOOL_ERRORS) ) {
            print( "  $io->{'fna'}\n" );
            for my $xferr ( @{$io->{'xferrs'}} ) {
              print( "    $xferr\n" );
            }
          }
        }
      }
    }
  }
  else {
    my $errobjc = scalar( keys( %errobjs ) );
    if ( $errobjc > 0 ) {
      warn( "Cannot process $errobjc objects with errors. Use command \"listerr\" to list them.\n" );
    }
  }
};
if ( $@ ) {
  push( @errors, $@ );
}

if ( scalar( @warnings ) > 0 ) {
  print STDERR ( "\n" );
  for my $warning ( @warnings ) {
    print STDERR ( $warning );
  }
}

if ( scalar( @errors ) > 0 ) {
  print STDERR ( "\n" );
  for my $error ( @errors ) {
    print STDERR ( $error );
  }
}

exit( 0 );
