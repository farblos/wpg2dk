#!/usr/bin/perl

#
# wpg2dk - Migrate from Windows Photo Gallery to digiKam.
#

use strict;
use warnings                    qw( FATAL all );

use DBI                         qw();
use DBD::SQLite::Constants      qw( :file_open );
use Data::Dumper                qw( Dumper );
use File::Spec::Functions       qw( catfile );
use Getopt::Long                qw( GetOptions :config no_ignore_case bundling );
use Hash::Util                  qw( lock_hashref lock_ref_keys_plus );
use IO::Handle                  qw();
use Image::ExifTool             qw();
use List::Util                  qw( notall );

$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse    = 1;

# media object message IDs.  Keep the values of these 20
# characters max.
use constant MSGID_INVALID_WPGMD     => "invalid_wpgmd";
use constant MSGID_NO_WPGMD          => "no_wpgmd";
use constant MSGID_IGNORED_FILE      => "ignored_file";
use constant MSGID_UNMAPPED_FILE     => "unmapped_file";
use constant MSGID_MISSING_FILE      => "missing_file";
use constant MSGID_DUPLICATE_FILE    => "duplicate_file";
use constant MSGID_IGNORED_XFILE     => "ignored_xfile";
use constant MSGID_UNMAPPED_XFILE    => "unmapped_xfile";
use constant MSGID_EXISTING_XFILE    => "existing_xfile";
use constant MSGID_DUPLICATE_XFILE   => "duplicate_xfile";
use constant MSGID_EXIFTOOL_WARNINGS => "exiftool_warnings";
use constant MSGID_EXIFTOOL_ERRORS   => "exiftool_errors";

my @MESSAGE_IDS = (
  MSGID_INVALID_WPGMD,
  MSGID_NO_WPGMD,
  MSGID_IGNORED_FILE,
  MSGID_UNMAPPED_FILE,
  MSGID_MISSING_FILE,
  MSGID_DUPLICATE_FILE,
  MSGID_IGNORED_XFILE,
  MSGID_UNMAPPED_XFILE,
  MSGID_EXISTING_XFILE,
  MSGID_DUPLICATE_XFILE,
  MSGID_EXIFTOOL_WARNINGS,
  MSGID_EXIFTOOL_ERRORS,
);

my %MESSAGE_FORMATS = (                                         # type  parameters
  (MSGID_INVALID_WPGMD)     => "  %i:\n    %s => %o\n",         # warn. $uiid, $msgidwpgmd, $object
  (MSGID_NO_WPGMD)          => "  %i:\n",                       # error $uiid
  (MSGID_IGNORED_FILE)      => "  %i:\n    %s\n",               # error $uiid, $fno
  (MSGID_UNMAPPED_FILE)     => "  %i:\n    %s\n",               # error $uiid, $fno
  (MSGID_MISSING_FILE)      => "  %i:\n    %s =>\n    %s\n",    # error $uiid, $fno, $fn
  (MSGID_DUPLICATE_FILE)    => "  %i:\n    %s =>\n    %s\n",    # error $uiid, $fno, $fn
  (MSGID_IGNORED_XFILE)     => "  %i:\n    %s\n",               # error $uiid, $xno
  (MSGID_UNMAPPED_XFILE)    => "  %i:\n    %s\n",               # error $uiid, $xno
  (MSGID_EXISTING_XFILE)    => "  %i:\n    %s =>\n    %s\n",    # error $uiid, $xno, $xn
  (MSGID_DUPLICATE_XFILE)   => "  %i:\n    %s =>\n    %s\n",    # error $uiid, $xno, $xn
  (MSGID_EXIFTOOL_WARNINGS) => "  %i: %o\n",                    # warn. $uiid, \@xfwarnings
  (MSGID_EXIFTOOL_ERRORS)   => "  %i: %o\n",                    # error $uiid, \@xferrors
);

# invalid WPG metadata message IDs
use constant MSGID_WPGMD_DUPLICATE_OID   => "duplicate_oid";
use constant MSGID_WPGMD_UNDEF_ATTRS     => "undef_attrs";
use constant MSGID_WPGMD_INVALID_REGION  => "invalid_region";
use constant MSGID_WPGMD_INVALID_PERSON  => "invalid_person";
use constant MSGID_WPGMD_DUBIOUS_PERSON  => "dubious_person";
use constant MSGID_WPGMD_INVALID_TAG     => "invalid_tag";
use constant MSGID_WPGMD_DUBIOUS_TAG     => "dubious_tag";
use constant MSGID_WPGMD_INVALID_GEOTAG  => "invalid_geotag";
use constant MSGID_WPGMD_DUBIOUS_GEOTAG  => "dubious_geotag";
use constant MSGID_WPGMD_DUP_GEOTAG      => "dup_geotag";

# invalid WPG tag metadata message IDs
use constant MSGID_WPGTAG_DUP_ID         => "dup_tag_id";
use constant MSGID_WPGTAG_UNDEF_NAME     => "undef_tag_name";
use constant MSGID_WPGTAG_UNDEF_PID      => "undef_tag_pid";
use constant MSGID_WPGTAG_MISSING_PID    => "missing_tag_pid";
use constant MSGID_WPGTAG_MISSING_ROOT   => "missing_tag_root";
use constant MSGID_WPGTAG_INVALID_GPS    => "invalid_gps";

# invalid WPG people metadata message IDs
use constant MSGID_WPGPPL_DUP_ID         => "dup_people_id";
use constant MSGID_WPGPPL_UNDEF_NAME     => "undef_people_name";

my %COMMANDS = (
  'summary' => 1,
  'listerr' => 1,
  'dump'    => 1,
  'list'    => 1,
  'extract' => 1,
);

use constant TAG_STRUCT_PATH  => "path";
use constant TAG_STRUCT_REC   => "rec";
use constant TAG_STRUCT_NODES => "nodes";
use constant TAG_STRUCT_LEAF  => "leaf";

my %TAG_STRUCTS = (
  (TAG_STRUCT_PATH)  => 1,
  (TAG_STRUCT_REC)   => 1,
  (TAG_STRUCT_NODES) => 1,
  (TAG_STRUCT_LEAF)  => 1,
);

#{{{ auxilliary functions

sub error
{
  print STDERR ( @_, "\n" );
  exit( 1 );
}

sub usage
{
  print STDERR ( @_, "\n" );
  exit( 2 );
}

# convert the specified structure to a string
sub s2s
{
  local $Data::Dumper::Indent = 0;
  return Dumper( $_[0] );
}

# brush up the specified error message
sub bue
{
  my $error = $_[0];
  $error =~ s/^\s+//;
  $error =~ s/\s+$//;
  $error =~ s/\s+/ /g;
  $error =~ s/ at .*? line \d+\.$//;
  return lcfirst( $error );
}

#}}}

#{{{ cavmap

# converts and verifies the specified map
sub cavmap
{
  for my $me ( @_ ) {
    my $fn = "";
    if ( $me =~ /^s\{.*\}\{.*\}[a-z]*$/m ) {
      if ( ! defined( do { package _wpg2dk; eval( "\$fn =~ $me" ) } ) ) {
        usage( "Invalid map entry \"$me\" (", bue( $@ ), ")" );
      }
    }
    elsif ( $me =~ /^(.*?)(?:=(.*))?$/m ) {
      my ( $search, $repl ) = ( $1, $2 );
      $repl //= "";
      if ( ! defined( do { package _wpg2dk; eval( '$fn =~ s/$search/$repl/g' ) } ) ) {
        usage( "Invalid map entry \"$me\" (", bue( $@ ), ")" );
      }
      $me = [ $me, $search, $repl ];
    }
    else {
      usage( "Invalid map entry \"$me\"" );
    }
  }
}

#}}}

#{{{ aplmap

# applies the specified map to the specified file name
sub aplmap
{
  my $fn = shift( @_ );
  for my $me ( @_ ) {
    if ( ! ref( $me ) ) {
      if ( ! defined( do { package _wpg2dk; eval( "\$fn =~ $me" ) } ) ) {
        error( "Cannot apply map entry \"$me\" to \"$fn\" (", bue( $@ ), ")" );
      }
    }
    else {
      my ( $me, $search, $repl ) = @{$me};
      if ( ! defined( do { package _wpg2dk; eval( '$fn =~ s/$search/$repl/g' ) } ) ) {
        error( "Cannot apply map entry \"$me\" to \"$fn\" (", bue( $@ ), ")" );
      }
    }
  }
  return $fn;
}

#}}}

#{{{ catnodes, readtree

sub catnodes
{
  my ( $id, $nodes ) = @_;

  my $node = $nodes->{$id}->[0];
  if ( exists( $node->{'done'} ) ) {
    # no-op
  }
  elsif ( (! defined( $node->{'pid'} )) ) {
    $node->{'done'} = 1;
    push( @{$node->{'warnings'}},
          [ MSGID_WPGTAG_UNDEF_PID, $node ] );
  }
  elsif ( ($node->{'pid'} == 0) ) {
    $node->{'done'} = 1;
  }
  elsif ( (! exists( $nodes->{$node->{'pid'}} )) ) {
    $node->{'done'} = 1;
    push( @{$node->{'warnings'}},
          [ MSGID_WPGTAG_MISSING_PID, $node ] );
  }
  else {
    $node->{'done'} = 1;
    catnodes( $node->{'pid'}, $nodes );
    push( @{$nodes->{$id}}, @{$nodes->{$node->{'pid'}}} );
  }
}

# reads the tree of (geo)tags from the specified statement handle
# and returns it as a hash mapping tag ids to arrays consisting
# of tag nodes
#
#   {
#      <id> => [ <tag-node-0>, ..., <tag-node-n> ],
#      ...,
#   }
#
# where tag node n has tag id <id> and tag node i-1 is the parent
# node of tag node i.
sub readtree
{
  my ( $sth ) = @_;

  my %nodes = ();
  while ( my $node = $sth->fetchrow_hashref() ) {
    my $id = $node->{'id'};
    $node->{'warnings'} = [];

    if ( (! defined( $id )) || ($id <= 0) ) {
      warn( "Cannot process undefined or non-positive node ID (", s2s( $node ), ")" );
      next;
    }

    if ( exists( $nodes{$id} ) ) {
      push( @{$nodes{$id}->[0]->{'warnings'}},
            [ MSGID_WPGTAG_DUP_ID, $node ] );
      next;
    }

    if ( (! defined( $node->{'name'} )) ||
         (length( $node->{'name'} ) == 0) ) {
      $node->{'name'} = "wpg2dk-generated-#$id";
      push( @{$node->{'warnings'}},
            [ MSGID_WPGTAG_UNDEF_NAME, $node ] );
    }

    $nodes{$id} = [ $node ];
  }

  # concatenate tag nodes along their path to root
  for my $id ( keys( %nodes ) ) {
    catnodes( $id, \%nodes );
  }

  # revert nodes
  for my $nodes ( values( %nodes ) ) {
    $nodes = [ reverse( @{$nodes} ) ];
  }

  # detect and flag rootless tag nodes (which can result from our
  # node loop detection)
  for my $nodes ( values( %nodes ) ) {
    if ( (defined( $nodes->[0]->{'pid'} )) &&
         ($nodes->[0]->{'pid'} != 0) ) {
      push( @{$nodes->[0]->{'warnings'}},
            [ MSGID_WPGTAG_MISSING_ROOT, $nodes->[0] ] );
    }
  }

  return \%nodes;
}

#}}}

#{{{ uiidmp

# returns whether the specified user interface ID matches the
# specified matchers
sub uiidmp
{
  my ( $uiid, $uiidms ) = @_;

  my $match = undef();
  if ( (scalar( @{$uiidms} ) == 0) || ($uiidms->[0] eq "-X") ) {
    $match = 1;
  }
  else {
    $match = 0;
  }

  my $inverted = 0;
  for my $uiidm ( @{$uiidms} ) {
    if ( ($uiidm eq "-X") && (! $inverted) ) {
      return 0 if ( ! $match );
      $inverted ^= 1;
    }
    elsif ( ($uiidm eq "-X") && ($inverted) ) {
      return 1 if ( $match );
      $inverted ^= 1;
    }
    elsif ( (! ref( $uiidm )) && ($uiid eq $uiidm) ) {
      $match = $inverted ? 0 : 1;
    }
    elsif ( (ref( $uiidm )) && ($uiid =~ /$uiidm/) ) {
      $match = $inverted ? 0 : 1;
    }
  }

  return $match;
}

#}}}

#{{{ object error handling

# media objects with warnings
my %warnobjs = ();

# hash that maps from message IDs to arrays of media objects
# having some warning message
my %warnids  = map { ($_ => []) } @MESSAGE_IDS;

# adds the specified warning to the specified media object and
# updates global variables on objects with warnings
sub addwarning
{
  my $obj     = shift( @_ );
  my $msgid   = shift( @_ );
  my $message = [ $msgid, @_ ];
  push( @{$obj->{'warnings'}}, $message );
  $warnobjs{$obj} = 1;
  push( @{$warnids{$msgid}}, $obj );
}

# media objects with errors
my %errobjs = ();

# hash that maps from message IDs to arrays of media objects
# having some error message
my %errids  = map { ($_ => []) } @MESSAGE_IDS;

# adds the specified error to the specified media object and
# updates global variables on erroneous objects
sub adderror
{
  my $obj     = shift( @_ );
  my $msgid   = shift( @_ );
  my $message = [ $msgid, @_ ];
  push( @{$obj->{'errors'}}, $message );
  $errobjs{$obj} = 1;
  push( @{$errids{$msgid}}, $obj );
}

# returns whether to continue processing the specified media
# object
sub continuep
{
  return scalar( @{$_[0]->{'errors'}} ) > 0 ? 0 : 1;
}

#}}}

#{{{ addxmptags

# adds one or more XMP tags to the specified set of XMP tags
# according to the specified remaining parameters
sub addxmptags
{
  my ( $xmptags, $tag, $tagstruct, $tagprfx ) = @_;

  local *addxmptag = sub {
    if ( defined( $tagprfx ) ) {
      $xmptags->{"$tagprfx/$_[0]"} = 1;
    }
    else {
      $xmptags->{"$_[0]"} = 1;
    }
  };

  if ( 0 ) {
    # alignment no-op
  }
  elsif ( $tagstruct eq TAG_STRUCT_PATH ) {
    addxmptag( join( "/", map { $_->{'name'} } @{$tag} ) );
  }
  elsif ( $tagstruct eq TAG_STRUCT_REC ) {
    addxmptag( join( "/", map { $_->{'name'} } @{$tag}[0 .. $_] ) ) for ( 0 .. $#{$tag} );
  }
  elsif ( $tagstruct eq TAG_STRUCT_NODES ) {
    addxmptag( $_->{'name'} ) for ( @{$tag} );
  }
  elsif ( $tagstruct eq TAG_STRUCT_LEAF ) {
    addxmptag( $tag->[-1]->{'name'} );
  }
}

#}}}

#{{{ writexmp

sub writexmp
{
  my ( $obj, $xmpopts ) = @_;

  my $xmpfn = $obj->{'xn'};
  my $xmpf  = undef();
  unless ( open( $xmpf, ">", $xmpfn ) ) {
    die( "Cannot open \"$xmpfn\" for writing (", bue( $! ), ")" );
  }

  my %xmptags = ();

  # write XMP header
  print $xmpf ( << "EOX" );
<?xpacket begin='ï»¿' id='W5M0MpCehiHzreSzNTczkc9d'?>
<x:xmpmeta xmlns:x='adobe:ns:meta/' x:xmptk='https://github.com/farblos/wpg2dk'>
<!-- $obj->{'uiid'} -->
<rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'>
EOX

  # write region information
  if ( notall { ($_->{'left'}  == 0) && ($_->{'top'}    == 0) &&
                ($_->{'width'} == 0) && ($_->{'height'} == 0) } @{$obj->{'people'}} ) {
    print $xmpf ( << 'EOX' );
 <rdf:Description rdf:about=''
  xmlns:MP='http://ns.microsoft.com/photo/1.2/'
  xmlns:MPRI='http://ns.microsoft.com/photo/1.2/t/RegionInfo#'
  xmlns:MPReg='http://ns.microsoft.com/photo/1.2/t/Region#'>
  <MP:RegionInfo rdf:parseType='Resource'>
   <MPRI:Regions>
    <rdf:Bag>
EOX

  for my $region ( @{$obj->{'people'}} ) {
    my $left   = $region->{'left'};
    my $top    = $region->{'top'};
    my $width  = $region->{'width'};
    my $height = $region->{'height'};

    my $xfornt = $obj->{'xfornt'};

    # skip region-less people
    if ( ($left   == 0) &&
         ($top    == 0) &&
         ($width  == 0) &&
         ($height == 0) ) {
      next;
    }
    # do not rotate region
    elsif ( (! defined( $xfornt )) ||
            ($xfornt == 1) ||
            ($xfornt == 2) ) {
      # no-op
    }
    # rotate region by 180 degree
    elsif ( ($xfornt == 3) ||
            ($xfornt == 4) ) {
      $left   = 1 - $left - $width;
      $top    = 1 - $top  - $height;
    }
    # rotate region by 90 degree CCW
    elsif ( ($xfornt == 5) ||
            ($xfornt == 6) ) {
      ( $left, $top, $width, $height ) =
      ( $top, 1 - $left - $width, $height, $width );
    }
    # rotate region by 270 degree CCW
    elsif ( ($xfornt == 7) ||
            ($xfornt == 8) ) {
      ( $left, $top, $width, $height ) =
      ( 1 - $top - $height, $left, $height, $width );
    }

    # mirror region horizontally
    if ( ($xfornt == 2) || ($xfornt == 4) || ($xfornt == 5) || ($xfornt == 7) ) {
      $top    = 1 - $top  - $height;
    }

    # sanitize top and left values
    $top  = 0 if ( $top  < 0 );
    $top  = 1 if ( $top  > 1 );
    $left = 0 if ( $left < 0 );
    $left = 1 if ( $left > 1 );

    # format floats to 6 places after the decimal point
    $left   = sprintf( '%0.6f', $left   );
    $top    = sprintf( '%0.6f', $top    );
    $width  = sprintf( '%0.6f', $width  );
    $height = sprintf( '%0.6f', $height );

    if ( defined( $region->{'name'} ) ) {
      print $xmpf ( << "EOX" );
     <rdf:li rdf:parseType='Resource'>
      <MPReg:PersonDisplayName>$region->{'name'}</MPReg:PersonDisplayName>
      <MPReg:Rectangle>$left, $top, $width, $height</MPReg:Rectangle>
     </rdf:li>
EOX
    }
    else {
      print $xmpf ( << "EOX" );
     <rdf:li rdf:parseType='Resource'>
      <MPReg:Rectangle>$left, $top, $width, $height</MPReg:Rectangle>
     </rdf:li>
EOX
    }
  }

    print $xmpf ( << 'EOX' );
    </rdf:Bag>
   </MPRI:Regions>
  </MP:RegionInfo>
 </rdf:Description>
EOX
  }

  # add people tags
  for my $region ( @{$obj->{'people'}} ) {
    if ( defined( $region->{'name'} ) ) {
      $xmptags{"People/" . $region->{'name'}} = 1;
    }
  }

  # write sync status
  print $xmpf ( << "EOX" ) if ( (defined( $xmpopts->{'pccl'} )) && ($obj->{'status'}) );
 <rdf:Description rdf:about=''
  xmlns:digiKam='http://www.digikam.org/ns/1.0/'>
  <digiKam:ColorLabel>$xmpopts->{'pccl'}</digiKam:ColorLabel>
 </rdf:Description>
EOX

  # add geotag
  if ( (defined( $obj->{'geotag'} )) ) {
    addxmptags( \%xmptags, $obj->{'geotag'}, $xmpopts->{'gtags'}, $xmpopts->{'gtr'} );
  }

  # write geotag coordinates
  if ( (defined( $obj->{'geotag'} )) &&
       (defined( $obj->{'geotag'}->[-1]->{'xflat'} )) &&
       (defined( $obj->{'geotag'}->[-1]->{'xflong'} )) ) {
    print $xmpf ( << "EOX" );
 <rdf:Description rdf:about=''
  xmlns:exif='http://ns.adobe.com/exif/1.0/'>
  <exif:GPSLatitude>$obj->{'geotag'}->[-1]->{'xflat'}</exif:GPSLatitude>
  <exif:GPSLongitude>$obj->{'geotag'}->[-1]->{'xflong'}</exif:GPSLongitude>
 </rdf:Description>
EOX
  }

  # write caption
  if ( defined( $obj->{'title'} ) ) {
    print $xmpf ( << "EOX" );
 <rdf:Description rdf:about=''
  xmlns:dc='http://purl.org/dc/elements/1.1/'>
  <dc:title>
   <rdf:Alt>
    <rdf:li xml:lang='x-default'>$obj->{'title'}</rdf:li>
   </rdf:Alt>
  </dc:title>
 </rdf:Description>
EOX
  }

  # add (descriptive) tags
  for my $tag ( @{$obj->{'tags'}} ) {
    addxmptags( \%xmptags, $tag, $xmpopts->{'tags'}, undef() );
  }

  # write rating
  print $xmpf ( << "EOX" ) if ( $obj->{'rating'} > 0 );
 <rdf:Description rdf:about=''
  xmlns:xmp='http://ns.adobe.com/xap/1.0/'>
  <xmp:Rating>$obj->{'rating'}</xmp:Rating>
 </rdf:Description>
EOX

  # write flag
  print $xmpf ( << "EOX" ) if ( $obj->{'flag'} );
 <rdf:Description rdf:about=''
  xmlns:digiKam='http://www.digikam.org/ns/1.0/'>
  <digiKam:PickLabel>$xmpopts->{'pl'}</digiKam:PickLabel>
 </rdf:Description>
EOX

  # write tags, if any
  if ( scalar( keys( %xmptags ) ) > 0 ) {
    print $xmpf ( << 'EOX' );
 <rdf:Description rdf:about=''
  xmlns:digiKam='http://www.digikam.org/ns/1.0/'>
  <digiKam:TagsList>
   <rdf:Seq>
EOX
    for my $xmptag ( sort( keys( %xmptags ) ) ) {
      print $xmpf ( "    <rdf:li>$xmptag</rdf:li>\n" );
    }
    print $xmpf ( << 'EOX' );
   </rdf:Seq>
  </digiKam:TagsList>
 </rdf:Description>
EOX
  }

  # write XMP footer
  print $xmpf ( << 'EOX' );
</rdf:RDF>
</x:xmpmeta>
<?xpacket end='w'?>
EOX

  close( $xmpf );
}

#}}}

#{{{ process commandline parameters

my $command = undef();
if ( scalar( @ARGV ) > 0 ) {
  $command = shift( @ARGV );
}
else {
  usage( "No command specified." );
}

if ( ! exists( $COMMANDS{$command} ) ) {
  usage( "Invalid command \"$command\" specified." );
}

my $force   = 0;
my @mmap    = ();
my @xmap    = ();
my $idtp    = "filename";
my $errfmt  = "structured";
my @msgids  = ();
my %xmpopts = (
  'pccl'    => undef(),
  'gtr'     => "Location",
  'gtags'   => TAG_STRUCT_PATH,
  'tags'    => TAG_STRUCT_PATH,
  'pl'      => "3",
);
{
  my $error = undef();
  local $SIG{'__WARN__'} = sub { $error = bue( $_[0] ) };
  if ( ! GetOptions( "f|force"             => \$force,
                     "m|mmap=s"            => \@mmap,
                     "x|xmap=s"            => \@xmap,
                     "i|idtype=s"          => \$idtp,
                     "e|error_format=s"    => \$errfmt,
                     "M|message_id=s"      => \@msgids,                 # "listerr" only
                       "pccl=s"            => \$xmpopts{'pccl'},        # "extract" only
                     "r|geotagroot=s"      => \$xmpopts{'gtr'},         # "extract" only
                     "g|geotags=s"         => \$xmpopts{'gtags'},       # "extract" only
                     "t|tags=s"            => \$xmpopts{'tags'},        # "extract" only
                     "p|pl=s"              => \$xmpopts{'pl'} ) ) {     # "extract" only
    usage( "Invalid commandline parameters specified ($error)." );
  }
}

# default XMP map
@xmap = 's{$}{.wpg2dk.xmp}' unless ( scalar( @xmap ) );

# convert and verify maps
cavmap( @mmap );
cavmap( @xmap );

# verify user interface ID type
if ( ($idtp ne "filename") &&
     ($idtp ne "oid") ) {
  usage( "Invalid user interface ID type \"$idtp\" specified." );
}

# verify error format
if ( ($errfmt ne "structured") &&
     ($errfmt ne "oneline") &&
     ($errfmt ne "short") ) {
  usage( "Invalid error format \"$errfmt\" specified." );
}

# verify message IDs
if ( scalar( @msgids ) > 0 ) {
  for my $msgid ( @msgids ) {
    if ( ! grep { $_ eq $msgid } @MESSAGE_IDS ) {
      usage( "Invalid message ID \"$msgid\" specified." );
    }
  }
}
else {
  @msgids = @MESSAGE_IDS;
}

# verify XMP generation options
if ( (defined( $xmpopts{'pccl'} )) &&
     ($xmpopts{'pccl'} !~ /^[0-9]$/) ) {
  usage( "Invalid people completeness color label \"$xmpopts{'pccl'}\" specified." );
}
if ( (length( $xmpopts{'gtr'} ) == 0) ) {
  usage( "Invalid empty geotag root specified." );
}
if ( (! exists( $TAG_STRUCTS{$xmpopts{'gtags'}} )) ) {
  usage( "Invalid geotag structure \"$xmpopts{'gtags'}\" specified." );
}
if ( (! exists( $TAG_STRUCTS{$xmpopts{'tags'}} )) ) {
  usage( "Invalid tag structure \"$xmpopts{'tags'}\" specified." );
}
if ( ($xmpopts{'pl'} !~ /^[0-5]$/) ) {
  usage( "Invalid pick label \"$xmpopts{'pl'}\" specified." );
}

my $dbn = undef();
if ( scalar( @ARGV ) > 0 ) {
  $dbn = shift( @ARGV );
}
else {
  usage( "No database name specified." );
}
if ( ! -f $dbn ) {
  usage( "Invalid database name \"$dbn\" specified." );
}

# verify UIID matchers (which are ignored for command "summary")
my @uiidms = @ARGV;
{
  my $prvnot = 0;
  for my $uiidm ( @uiidms ) {
    if ( ($uiidm eq "-X") && (! $prvnot) ) {
      $prvnot = 1;
    }
    elsif ( ($uiidm eq "-X") && ($prvnot) ) {
      usage( "Invalid double negation in UIID matchers." );
    }
    else {
      $prvnot = 0;
    }

    if ( $uiidm =~ /^m\{(.*)\}$/m ) {
      my $uiidre = $1;
      if ( defined( $uiidre = do { package _wpg2dk; eval( 'qr{$uiidre}' ) } ) ) {
        $uiidm = $uiidre;
      }
      else {
        usage( "Invalid UIID matcher \"$uiidm\" (", bue( $@ ), ")" );
      }
    }
  }
  if ( $prvnot ) {
    usage( "Invalid trailing negation in UIID matchers." );
  }
}

#}}}

STDOUT->autoflush( 1 );
STDERR->autoflush( 1 );

my $exiftool = new Image::ExifTool();

my @errors   = ();
my @warnings = ();
$SIG{'__WARN__'} = sub { push( @warnings, $_[0] ) };

eval {

  my $dbh = DBI->connect( "dbi:SQLite:dbname=$dbn", undef(), undef(),
                          {
                            'sqlite_open_flags' => SQLITE_OPEN_READONLY,
                            'RaiseError'        => 1,
                          } );
  my $sth = undef();

#{{{ read media objects

  # read all media objects ...
  $sth = $dbh->prepare( q{
    select    o.objectid   oid,
              o.syncstatus status,
              o.title      title,
              o.rating     rating,
              o.flagged    flag,
              v.volumeid   volid,
              p.path       pn,
              o.filename   fn
    from      tblobject o
    left join tblpath   p on o.filepathid = p.pathid
    left join tblvolume v on p.volumeid   = v.volumeid
    order by  volid nulls first, pn nulls first, fn nulls first
  } );
  $sth->execute();

  # ... and store them in nearly-global structures, adding some
  # essential attributes on the way.  The resulting media object
  # looks like this:
  #
  #   {
  #     # selected from tblobject above, brushed up below
  #     'oid'      => (! defined( $_ ) || (integer( $_ )),
  #     'status'   => (($_ == 0) || ($_ == 1)),
  #     'title'    => (! defined( $_ )) || (string( $_ ) && (length( $_ ) > 0)),
  #     'rating'   => defined( $_ ) && integer( $_ ),
  #     'flag'     => defined( $_ ) && integer( $_ ),
  #     'volid'    => (! defined( $_ )) || (integer( $_ )),
  #     'pn'       => (! defined( $_ )) || (string( $_ )),
  #     'fn'       => (! defined( $_ )) || (string( $_ )),
  #
  #     # added by below loop
  #     'uidd'     => defined( $_ ) && string( $_ ),
  #     'errors'   => [ [ MSGID_*, $msgparam, ... ], ... ],
  #     'warnings' => [ [ MSGID_*, $msgparam, ... ], ... ],
  #     'people'   => [ $region, ... ],
  #     'geotag'   => (! defined( $_ )) || ([ $geotagnode, ... ]),
  #     'tags'     => [ [ $tagnode, ...], ... ],
  #
  #     # added even later on demand
  #     'fno'      => (! defined( $_ )) || (string( $_ )),
  #     'fn'       => (! defined( $_ )) || (string( $_ )),
  #     'xno'      => (! defined( $_ )) || (string( $_ )),
  #     'xn'       => (! defined( $_ )) || (string( $_ )),
  #     'xfornt'   => (! defined( $_ )) || (integer( $_ )),
  #   }
  my %objs = ();
  my @objs = ();
  while ( my $obj = $sth->fetchrow_hashref() ) {
    # derive the user interface ID from the WPG metadata.  Be
    # relaxed with respect to undefined attributes, which we will
    # handle later.
    my $uiid = undef();
    if ( $idtp eq "oid" ) {
      $uiid = $obj->{'oid'} // "null";
    }
    else {
      $uiid = "#" . ($obj->{'volid'} // "null") .
                    catfile( split( /\\/, ($obj->{'pn'} || "null") ),
                             ($obj->{'fn'} || "null") );
      if ( -f (my $muiid = aplmap( $uiid, @mmap )) ) {
        $uiid = $muiid;
      }
    }
    $obj->{'uiid'}     = $uiid;

    $obj->{'errors'}   = [];
    $obj->{'warnings'} = [];

    $obj->{'people'}   = [];
    $obj->{'geotag'}   = undef();
    $obj->{'tags'}     = [];

    lock_ref_keys_plus( $obj, 'fno', 'fn', 'xno', 'xn',
                              'xfornt' );

    my $oid = $obj->{'oid'} || "null";
    if ( ! exists( $objs{$oid} ) ) {
      $objs{$oid} = [ $obj ];
    }
    elsif ( scalar( @{$objs{$oid}} ) == 1 ) {
      addwarning( $objs{$oid}->[0], MSGID_INVALID_WPGMD,
                                    MSGID_WPGMD_DUPLICATE_OID,
                                    $oid );
      addwarning( $obj, MSGID_INVALID_WPGMD,
                        MSGID_WPGMD_DUPLICATE_OID,
                        $oid );
      push( @{$objs{$oid}}, $obj );
    }
    else {
      addwarning( $obj, MSGID_INVALID_WPGMD,
                        MSGID_WPGMD_DUPLICATE_OID,
                        $oid );
      push( @{$objs{$oid}}, $obj );
    }
    push( @objs, $obj );
  }

  # handle undefined attributes, brush up others
  for my $obj ( @objs ) {
    if ( (defined( $obj->{'oid'} ))   &&
         (defined( $obj->{'volid'} )) &&
         (defined( $obj->{'pn'} ))    &&
         (length( $obj->{'pn'} ) > 0) &&
         (defined( $obj->{'fn'} ))    &&
         (length( $obj->{'fn'} ) > 0) ) {
      # no-op
    }
    else {
      addwarning( $obj, MSGID_INVALID_WPGMD,
                        MSGID_WPGMD_UNDEF_ATTRS,
                        undef() );
    }

    if ( (! defined( $obj->{'status'} )) ) {
      $obj->{'status'} = 0;
    }
    elsif ( ($obj->{'status'} & 2048) ) {
      $obj->{'status'} = 1;
    }
    else {
      $obj->{'status'} = 0;
    }
    if ( (defined( $obj->{'title'} )) &&
         ($obj->{'title'} eq "") ) {
      $obj->{'title'}  = undef()
    }
    $obj->{'rating'} //= 0;
    $obj->{'flag'}   //= 0;
  }

#}}}

#{{{ read persons and regions and attach them to media objects

  # read persons into a hash mapping positive person IDs to
  # hashes
  #
  #   {
  #      'pid'      => (defined( $_ ) && integer( $_ ) && ($_ > 0)),
  #      'name'     => (defined( $_ ) && string( $_ )  && (length( $_ ) > 0),
  #      'warnings' => [ [ MSGID_WPGPPL_*, $object ], ... ],
  #   }
  my %persons = ();
  $sth = $dbh->prepare( q{
    select personid pid,
           name     name
    from   tblperson
  } );
  $sth->execute();
  while ( my $person = $sth->fetchrow_hashref() ) {
    my $pid = $person->{'pid'};
    $person->{'warnings'} = [];

    if ( (! defined( $pid )) || ($pid <= 0) ) {
      warn( "Cannot process undefined or invalid person ID of person (", s2s( $person ), ").\n" );
    }
    elsif ( exists( $persons{$pid} ) ) {
      push( @{$persons{$pid}->{'warnings'}},
            [ MSGID_WPGPPL_DUP_ID, $person ] );
    }
    elsif ( (! defined( $person->{'name'} )) ||
            (length( $person->{'name'} ) == 0) ) {
      $person->{'name'} = "wpg2dk-generated-#$pid";
      push( @{$person->{'warnings'}},
            [ MSGID_WPGPPL_UNDEF_NAME, $person ] );
    }

    lock_hashref( $person );

    $persons{$pid} = $person;
  }

  # read regions and attach them to objects.  Region format is
  #
  #   {
  #     'oid'    => (defined( $_ ) && integer( $_ ) && exists( $objs{$_} )),
  #     'pid'    => (defined( $_ ) && integer( $_ )),
  #     'name'   => (! defined( $_ )) ||
  #                 (defined( $_ ) && string( $_ )  && (length( $_ ) > 0)),
  #     'left'   => (defined( $_ ) && float( $_ )   && (0 <= $_ <= 1),
  #     'top'    => (defined( $_ ) && float( $_ )   && (0 <= $_ <= 1),
  #     'width'  => (defined( $_ ) && float( $_ )   && (0 <= $_ <= 1),
  #     'height' => (defined( $_ ) && float( $_ )   && (0 <= $_ <= 1),
  #   }
  #
  # where region position and size is not all zero if the name is
  # undefined.
  #
  # Force lowercase column names.
  $sth = $dbh->prepare( q{
    select objectid oid,
           personid pid,
           left     "left",
           top      top,
           width    width,
           height   height
    from   tblregion
  } );
  $sth->execute();
  while ( my $region = $sth->fetchrow_hashref() ) {
    my ( $oid, $pid ) = @{$region}{'oid', 'pid'};

    if ( (! defined( $oid )) ||
         (! exists( $objs{$oid} )) ) {
      warn( "Cannot process undefined or invalid object ID of region (", s2s( $region ), ").\n" );
    }
    elsif ( (! defined( $pid ))                ||
            (! defined( $region->{'left'} ))   ||
            (! defined( $region->{'top'} ))    ||
            (! defined( $region->{'width'} ))  ||
            (! defined( $region->{'height'} )) ||
            ($region->{'left'}   < 0)          ||
            ($region->{'top'}    < 0)          ||
            ($region->{'width'}  < 0)          ||
            ($region->{'height'} < 0)          ||
            ($region->{'left'}   > 1)          ||
            ($region->{'top'}    > 1)          ||
            ($region->{'width'}  > 1)          ||
            ($region->{'height'} > 1)          ||
            (($pid                == 0) &&
             ($region->{'left'}   == 0) &&
             ($region->{'top'}    == 0) &&
             ($region->{'width'}  == 0) &&
             ($region->{'height'} == 0)) ) {
      addwarning( $_, MSGID_INVALID_WPGMD,
                      MSGID_WPGMD_INVALID_REGION,
                      $region ) for ( @{$objs{$oid}} );
    }
    elsif ( ($pid != 0) &&
            (! exists( $persons{$pid} )) ) {
      $region->{'name'} = "wpg2dk-generated-#$pid";
      push( @{$_->{'people'}}, $region ) for ( @{$objs{$oid}} );
      addwarning( $_, MSGID_INVALID_WPGMD,
                      MSGID_WPGMD_INVALID_PERSON,
                      $region ) for ( @{$objs{$oid}} );
    }
    elsif ( ($pid == 0) ) {
      $region->{'name'} = undef();
      push( @{$_->{'people'}}, $region ) for ( @{$objs{$oid}} );
    }
    else {
      $region->{'name'} = $persons{$pid}->{'name'};
      push( @{$_->{'people'}}, $region ) for ( @{$objs{$oid}} );
      if ( scalar( @{$persons{$pid}->{'warnings'}} ) > 0 ) {
        addwarning( $_, MSGID_INVALID_WPGMD,
                        MSGID_WPGMD_DUBIOUS_PERSON,
                        $persons{$pid} ) for ( @{$objs{$oid}} );
      }
    }

    lock_hashref( $region );
  }

#}}}

#{{{ read geotags and attach them to media objects

  $sth = $dbh->prepare( q{
    select locationid       id,
           locationname     name,
           locationparentid pid,
           locationlat      lat,
           locationlong     long
    from   tbllocation
  } );
  $sth->execute();

  # read geotags into a hash mapping positive geotag IDs to path
  # arrays of geotag nodes, where each geotag node has the
  # following format (at least after completion of the loop
  # below):
  #
  #   {
  #     'id'       => (defined( $_ ) && integer( $_ ) && ($_ > 0)),
  #     'name'     => (defined( $_ ) && string( $_ )  && (length( $_ ) > 0)),
  #     'pid'      => (defined( $_ ) && integer( $_ ) && ($_ >= 0)),
  #     'lat'      => (! defined( $_ )) ||
  #                   (defined( $_ ) && float( $_ ) && (-90  <= $_ <= 90)),
  #     'long'     => (! defined( $_ )) ||
  #                   (defined( $_ ) && float( $_ ) && (-180 <= $_ <= 180)),
  #     'xflat'    => (! defined( $_ )) ||
  #                   (defined( $_ ) && xflat( $_ )),
  #     'xflong'   => (! defined( $_ )) ||
  #                   (defined( $_ ) && xflong( $_ )),
  #     'warnings' => [ [ MSGID_WPGTAG_*, $object ], ...],
  #   }
  #
  # where all GPS-related attributes are either all undefined or
  # all defined and the 'xf*' attributes are the result of
  # converting the raw, WPG-provided attributes into something
  # EXIF-compatible.
  my $geotags = readtree( $sth );

  # verify latitude and longitude values of geotag nodes and
  # convert them into the EXIF format
  for my $node ( map { @{$_} } values( %{$geotags} ) ) {
    my $lat  = $node->{'lat'};
    my $long = $node->{'long'};

    if ( (exists( $node->{'xflat'} )) &&
         (exists( $node->{'xflong'} )) ) {
      # no-op
    }
    elsif ( (! defined( $lat )) &&
            (! defined( $long )) ) {
      $node->{'xflat'}  = undef();
      $node->{'xflong'} = undef();
    }
    elsif ( (defined( $lat )) &&
            (my @lat = ($lat =~ /^(-?)(\d+)\.(\d+)$/)) &&
            (-90 <= $lat) && ($lat <= 90) &&
            (defined( $long )) &&
            (my @long = ($long =~ /^(-?)(\d+)\.(\d+)$/)) &&
            (-180 <= $long) && ($long <= 180) ) {
      my $latmins  = "0.$lat[2]"  * 60.0;
      my $longmins = "0.$long[2]" * 60.0;
      $node->{'xflat'}  = sprintf( "%d,%f%s", $lat[1], "0.$lat[2]" * 60.0,
                                              ($lat[0] ? "S" : "N") );
      $node->{'xflong'} = sprintf( "%d,%f%s", $long[1], "0.$long[2]" * 60.0,
                                              ($long[0] ? "W" : "E") );
    }
    else {
      $node->{'lat'}    = undef();
      $node->{'long'}   = undef();
      $node->{'xflat'}  = undef();
      $node->{'xflong'} = undef();
      push( @{$node->{'warnings'}},
            [ MSGID_WPGTAG_INVALID_GPS, $node ] );
    }

    lock_hashref( $node );
  }

  # attach geotags to objects
  $sth = $dbh->prepare( q{
    select locationid       id,
           objectid         oid
    from   tblocationUsage
  } );
  $sth->execute();
  while ( my @row = $sth->fetchrow_array() ) {
    my ( $id, $oid ) = @row;

    if ( (! defined( $oid )) ||
         (! exists( $objs{$oid} )) ) {
      warn( "Cannot process undefined or invalid object ID of geotag (", s2s( \@row ), ").\n" );
    }
    elsif ( (! defined( $id )) ||
            (! exists( $geotags->{$id} )) ) {
      addwarning( $_, MSGID_INVALID_WPGMD,
                      MSGID_WPGMD_INVALID_GEOTAG,
                      $id ) for ( @{$objs{$oid}} );
    }
    else {
      for my $obj ( @{$objs{$oid}} ) {
        if ( defined( $obj->{'geotag'} ) ) {
          addwarning( $obj, MSGID_INVALID_WPGMD,
                            MSGID_WPGMD_DUP_GEOTAG,
                            $geotags->{$id} );
        }
        else {
          $obj->{'geotag'} = $geotags->{$id};
          if ( grep( scalar( @{$_->{'warnings'}} ), @{$geotags->{$id}} ) ) {
            addwarning( $obj, MSGID_INVALID_WPGMD,
                              MSGID_WPGMD_DUBIOUS_GEOTAG,
                              $geotags->{$id} );
          }
        }
      }
    }
  }

#}}}

#{{{ read tags and attach them to media objects

  $sth = $dbh->prepare( q{
    select labelid       id,
           labelname     name,
           parentlabelid pid
    from   tbllabel
  } );
  $sth->execute();

  # read tags into a hash mapping positive tag IDs to path arrays
  # of tag nodes, where each tag node has the following format:
  #
  #   {
  #     'id'       => (defined( $_ ) && integer( $_ ) && ($_ > 0)),
  #     'name'     => (defined( $_ ) && string( $_ )  && (length( $_ ) > 0)),
  #     'pid'      => (defined( $_ ) && integer( $_ ) && ($_ >= 0)),
  #     'warnings' => [ [ MSGID_WPGTAG_*, $object ], ...],
  #   }
  my $tags = readtree( $sth );

  for my $node ( map { @{$_} } values( %{$tags} ) ) {
    lock_hashref( $node );
  }

  # attach tags to objects
  $sth = $dbh->prepare( q{
    select labelid       id,
           objectid      oid
    from   tbllabelusage
  } );
  $sth->execute();
  while ( my @row = $sth->fetchrow_array() ) {
    my ( $id, $oid ) = @row;

    if ( (! defined( $oid )) ||
         (! exists( $objs{$oid} )) ) {
      warn( "Cannot process undefined or invalid object ID of tag (", s2s( \@row ), ").\n" );
    }
    elsif ( (! defined( $id )) ||
            (! exists( $tags->{$id} )) ) {
      addwarning( $_, MSGID_INVALID_WPGMD,
                      MSGID_WPGMD_INVALID_TAG,
                      $id ) for ( @{$objs{$oid}} );
    }
    else {
      push( @{$_->{'tags'}}, $tags->{$id} ) for ( @{$objs{$oid}} );
      if ( grep( scalar( @{$_->{'warnings'}} ), @{$tags->{$id}} ) ) {
        addwarning( $_, MSGID_INVALID_WPGMD,
                        MSGID_WPGMD_DUBIOUS_TAG,
                        $tags->{$id} ) for ( @{$objs{$oid}} );
      }
    }
  }

#}}}

#{{{ post-process media objects

  # check whether we have metadata worth extracting
  for my $obj ( @objs ) {
    if ( continuep( $obj ) ) {
      # consider "status" only if option "-pccl" has been
      # specified
      if ( ((! defined( $xmpopts{'pccl'} )) ||
            ($obj->{'status'} == 0))       &&
           (! defined( $obj->{'title'} ))  &&
           ($obj->{'rating'} == 0)         &&
           ($obj->{'flag'} == 0)           &&
           (@{$obj->{'people'}} == 0)      &&
           (! defined( $obj->{'geotag'} )) &&
           (@{$obj->{'tags'}} == 0) ) {
        adderror( $obj, MSGID_NO_WPGMD );
      }
    }
  }

  # map file names and look up media metadata
  my %fns = ();
  my %xns = ();
  for my $obj ( @objs ) {
    if ( continuep( $obj ) ) {
      # determine original (aka. pseudo) and mapped media file
      # name
      my $fno = "#" . ($obj->{'volid'} // "null") .
                      catfile( split( /\\/, ($obj->{'pn'} || "null") ),
                               ($obj->{'fn'} || "null") );
      my $fn  = aplmap( $fno, @mmap );

      # likewise for the intermediate XMP file name
      my $xno = $fn;
      my $xn  = aplmap( $fn, @xmap );

      $obj->{'fno'} = $fno;
      $obj->{'fn'}  = $fn;
      $obj->{'xno'} = $xno;
      $obj->{'xn'}  = $xn;

      if ( length( $fn ) == 0 ) {
        adderror( $obj, MSGID_IGNORED_FILE, $fno );
      }
      elsif ( $fn eq $fno ) {
        adderror( $obj, MSGID_UNMAPPED_FILE, $fno );
      }
      elsif ( ! -f $fn ) {
        adderror( $obj, MSGID_MISSING_FILE, $fno, $fn );
      }
      elsif ( ! exists( $fns{$fn} ) ) {
        $fns{$fn} = [ $obj ];
      }
      elsif ( scalar( @{$fns{$fn}} ) == 1 ) {
        adderror( $fns{$fn}->[0], MSGID_DUPLICATE_FILE,
                                  $fns{$fn}->[0]->{'fno'}, $fn );
        adderror( $obj, MSGID_DUPLICATE_FILE, $fno, $fn );
        push( @{$fns{$fn}}, $obj );
      }
      else {
        adderror( $obj, MSGID_DUPLICATE_FILE, $fno, $fn );
        push( @{$fns{$fn}}, $obj );
      }
    }

    if ( continuep( $obj ) ) {
      my $xno = $obj->{'xno'};
      my $xn  = $obj->{'xn'};

      if ( length( $xn ) == 0 ) {
        adderror( $obj, MSGID_IGNORED_XFILE, $xno );
      }
      elsif ( $xn eq $xno ) {
        adderror( $obj, MSGID_UNMAPPED_XFILE, $xno );
      }
      elsif ( (-e $xn) && (($command ne "list") && (! $force)) ) {
        adderror( $obj, MSGID_EXISTING_XFILE, $xno, $xn );
      }
      elsif ( ! exists( $xns{$xn} ) ) {
        $xns{$xn} = [ $obj ];
      }
      elsif ( scalar( @{$xns{$xn}} ) == 1 ) {
        adderror( $xns{$xn}->[0], MSGID_DUPLICATE_XFILE,
                                  $xns{$xn}->[0]->{'xno'}, $xn );
        adderror( $obj, MSGID_DUPLICATE_FILE, $xno, $xn );
        push( @{$xns{$xn}}, $obj );
      }
      else {
        adderror( $obj, MSGID_DUPLICATE_XFILE, $xno, $xn );
        push( @{$xns{$xn}}, $obj );
      }
    }

    # call ExifTool only if required
    if ( (continuep( $obj )) &&
         (notall { ($_->{'left'}  == 0) && ($_->{'top'}    == 0) &&
                   ($_->{'width'} == 0) && ($_->{'height'} == 0) } @{$obj->{'people'}}) ) {
      my $fn = $obj->{'fn'};

      # determine media file metadata
      my $info = $exiftool->ImageInfo( $fn,
                                       [ 'IFD0:Orientation',
                                         'ExifTool:Warning',
                                         'ExifTool:Error' ],
                                       { 'PrintConv' => 0 } );

      # we do trust Phil, so no checks on these values
      $obj->{'xfornt'} = $info->{'Orientation'};

      # convert ExifTool warnings and errors into media object
      # warnings and errors, respectively
      my @xfwarnings = ();
      my @xferrors   = ();
      for my $tag ( sort( keys( %{$info} ) ) ) {
        next if ( ($tag =~ /^Warning\b/) &&
                  (defined( $info->{$tag} )) &&
                  (lc( $info->{$tag}) eq "[minor] fixed incorrect uri for xmlns:microsoftphoto") );
        push( @xfwarnings, bue( $info->{$tag} ) ) if ( $tag =~ /^Warning\b/ );
        push( @xferrors,   bue( $info->{$tag} ) ) if ( $tag =~ /^Error\b/ );
      }
      if ( scalar( @xfwarnings ) > 0 ) {
        addwarning( $obj, MSGID_EXIFTOOL_WARNINGS, \@xfwarnings );
      }
      if ( scalar( @xferrors ) > 0 ) {
        adderror( $obj, MSGID_EXIFTOOL_ERRORS, \@xferrors );
      }
    }
    elsif ( (continuep( $obj )) ) {
      $obj->{'xfornt'} = undef();
    }
  }

#}}}

  # determine number of media objects, with errors, without
  # errors but with warnings, without any issues
  my $totobjc = scalar( @objs );
  my $errobjc = scalar( keys( %errobjs ) );
  my $wrnobjc = 0;
  for my $objkey ( keys( %warnobjs ) ) {
    $wrnobjc++ if ( ! exists( $errobjs{$objkey} ) );
  }
  my $okobjc  = $totobjc - $errobjc - $wrnobjc;

#{{{ command "summary"

  if ( $command eq "summary" ) {
    print(  "Media object counts:\n" );
    print(  "\n" );
    printf( "  total                %6d\n", $totobjc );
    printf( "  with errors          %6d\n", $errobjc );
    printf( "  with warnings        %6d\n", $wrnobjc );
    printf( "  without any issues   %6d\n", $okobjc );

    if ( $errobjc > 0 ) {
    print(  "\n" );
    print(  "Media object counts by error category.  Objects having\n" );
    print(  "errors with different categories are counted more than once.\n" );
    print(  "\n" );
    for my $msgid ( @MESSAGE_IDS ) {
    if ( scalar( @{$errids{$msgid}} ) > 0 ) {
    printf( "  %-20s %6d\n", $msgid, scalar( @{$errids{$msgid}} ) );
    }
    }
    }

    if ( $wrnobjc > 0 ) {
    print(  "\n" );
    print(  "Media object counts by warning category.  Objects having errors\n" );
    print(  "are not counted here.  Objects having warnings with different\n" );
    print(  "categories are counted more than once.\n" );
    print(  "\n" );
    for my $msgid ( @MESSAGE_IDS ) {
    if ( scalar( @{$warnids{$msgid}} ) > 0 ) {
    printf( "  %-20s %6d\n", $msgid, scalar( @{$warnids{$msgid}} ) );
    }
    }
    }

    if ( ($errobjc > 0) || ($wrnobjc > 0) ) {
    print(  "\n" );
    print(  "Use command \"listerr\" to list objects with errors or warnings.\n" );
    }
  }

#}}}

#{{{ command "listerr"

  elsif ( $command eq "listerr" ) {
    for my $msgid ( @msgids ) {
      if ( (scalar( @{$warnids{$msgid}} ) > 0) ||
           (scalar( @{$errids{$msgid}} ) > 0) ) {
        print( "$msgid\n" ) if ( $errfmt eq "structured" );
        for my $obj ( @{$warnids{$msgid}}, @{$errids{$msgid}} ) {
          next if ( ! uiidmp( $obj->{'uiid'}, \@uiidms ) );

          for my $error ( grep { $_->[0] eq $msgid }
                               @{$obj->{'warnings'}},
                               @{$obj->{'errors'}} ) {
            my $uiid = $obj->{'uiid'};
            my ( undef(), @msgprms ) = @{$error};
            my $msgfmt = $MESSAGE_FORMATS{$msgid};

            # process "%i" placeholders (only allowed at the
            # beginning of the format)
            if ( $msgfmt =~ s/^( *)%i/$1%s/ ) {
              unshift( @msgprms, $uiid );
            }

            # process "%o" placeholders (only allowed at the end
            # of the format) and remember indentation
            my $indent = "";
            if ( $msgfmt =~ s/^( +)(.*)%o$/$1$2%s/s ) {
              $indent = $1;
            }

            if ( $errfmt eq "structured" ) {
              printf( $msgfmt,
                      map { ! defined( $_ ) ? "undef" :
                            ! ref( $_ ) ? $_ :
                            do { my $s = Dumper( $_ ); chomp( $s );
                                 $s =~ s/\n/\n$indent/g; $s } }
                      @msgprms );
            }
            elsif ( $errfmt eq "oneline" ) {
              $msgfmt =~ s/\s+(?=\S)//g;
              printf( "$msgid:$msgfmt",
                      map { ! defined( $_ ) ? "undef" :
                            ! ref( $_ ) ? $_ : s2s( $_ ) }
                      @msgprms );
            }
            else {
              print( "$msgid:$uiid\n" );
            }
          }
        }
      }
    }
  }

#}}}

#{{{ commands "dump", "list", "extract"

  else {
    # same as above, limited to the current command execution
    my $totobjcc = 0;
    my $errobjcc = 0;
    my $wrnobjcc = 0;
    my $okobjcc  = 0;

    for my $obj ( @objs ) {
      next if ( ! uiidmp( $obj->{'uiid'}, \@uiidms ) );

      # update object counters
      $totobjcc++;
      if ( exists( $errobjs{$obj} ) ) {
        $errobjcc++;
      }
      elsif ( exists( $warnobjs{$obj} ) ) {
        $wrnobjcc++;
      }
      else {
        $okobjcc++;
      }

      # process command
      if ( ($command eq "dump") ) {
        print( Dumper( $obj ) );
      }
      elsif ( ($command eq "list") && (continuep( $obj )) ) {
        print( $obj->{'uiid'}, "\n" );
      }
      elsif ( ($command eq "extract") && (continuep( $obj )) ) {
        writexmp( $obj, \%xmpopts );
      }
    }

    print  STDERR ( "Media objects statistics:\n" );
    printf STDERR ( "Total:    %6d, with errors: %5d, with warnings: %5d, OK: %5d\n",
                    $totobjc, $errobjc, $wrnobjc, $okobjc );
    printf STDERR ( "Selected: %6d, with errors: %5d, with warnings: %5d, OK: %5d\n",
                    $totobjcc, $errobjcc, $wrnobjcc, $okobjcc );
    if ( $command ne "dump" ) {
    print  STDERR ( "Media objects with errors have not been processed.\n" );
    }
  }

#}}}

};
if ( $@ ) {
  push( @errors, $@ );
}

#{{{ handle global warnings and errors

if ( scalar( @warnings ) > 0 ) {
  print STDERR ( "\n" );
  print STDERR ( "Global warnings:\n" );
  print STDERR ( $_ ) for ( @warnings );
}

if ( scalar( @errors ) > 0 ) {
  print STDERR ( "\n" );
  print STDERR ( "Global errors:\n" );
  print STDERR ( $_ ) for ( @errors );
}

if ( scalar( @errors ) == 0 ) {
  exit( 0 );
}
else {
  exit( 1 );
}

#}}}
