#!/usr/bin/perl

#
# wpg2dk - Migrate from Windows Photo Gallery to digiKam.
#

use strict;
use warnings                    qw( FATAL all );

use DBI                         qw();
use DBD::SQLite::Constants      qw( :file_open );
use Data::Dumper                qw( Dumper );
use File::Spec::Functions       qw( catfile );
use Getopt::Long                qw( GetOptions :config no_ignore_case bundling );
use IO::Handle                  qw();
use Image::ExifTool             qw();

$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse    = 1;

# media object message IDs.  Keep the values of these 20
# characters max.
use constant MSGID_INVALID_WPGMD     => "invalid_wpgmd";
use constant MSGID_NO_WPGMD          => "no_wpgmd";
use constant MSGID_IGNORED_FILE      => "ignored_file";
use constant MSGID_UNMAPPED_FILE     => "unmapped_file";
use constant MSGID_MISSING_FILE      => "missing_file";
use constant MSGID_DUPLICATE_FILE    => "duplicate_file";
use constant MSGID_IGNORED_XFILE     => "ignored_xfile";
use constant MSGID_UNMAPPED_XFILE    => "unmapped_xfile";
use constant MSGID_EXISTING_XFILE    => "existing_xfile";
use constant MSGID_DUPLICATE_XFILE   => "duplicate_xfile";
use constant MSGID_EXIFTOOL_WARNINGS => "exiftool_warnings";
use constant MSGID_EXIFTOOL_ERRORS   => "exiftool_errors";

my @MESSAGE_IDS = (
  MSGID_INVALID_WPGMD,
  MSGID_NO_WPGMD,
  MSGID_IGNORED_FILE,
  MSGID_UNMAPPED_FILE,
  MSGID_MISSING_FILE,
  MSGID_DUPLICATE_FILE,
  MSGID_IGNORED_XFILE,
  MSGID_UNMAPPED_XFILE,
  MSGID_EXISTING_XFILE,
  MSGID_DUPLICATE_XFILE,
  MSGID_EXIFTOOL_WARNINGS,
  MSGID_EXIFTOOL_ERRORS,
);

my %MESSAGE_FORMATS = (                                         # type  parameters
  (MSGID_INVALID_WPGMD)     => "  %i:\n    %s => %o\n",         # warn. $uiid, $msgidwpgmd, $object
  (MSGID_NO_WPGMD)          => "  %i:\n",                       # error $uiid
  (MSGID_IGNORED_FILE)      => "  %i:\n    %s\n",               # error $uiid, $fno
  (MSGID_UNMAPPED_FILE)     => "  %i:\n    %s\n",               # error $uiid, $fno
  (MSGID_MISSING_FILE)      => "  %i:\n    %s =>\n    %s\n",    # error $uiid, $fno, $fn
  (MSGID_DUPLICATE_FILE)    => "  %i:\n    %s =>\n    %s\n",    # error $uiid, $fno, $fn
  (MSGID_IGNORED_XFILE)     => "  %i:\n    %s\n",               # error $uiid, $xno
  (MSGID_UNMAPPED_XFILE)    => "  %i:\n    %s\n",               # error $uiid, $xno
  (MSGID_EXISTING_XFILE)    => "  %i:\n    %s =>\n    %s\n",    # error $uiid, $xno, $xn
  (MSGID_DUPLICATE_XFILE)   => "  %i:\n    %s =>\n    %s\n",    # error $uiid, $xno, $xn
  (MSGID_EXIFTOOL_WARNINGS) => "  %i: %o\n",                    # warn. $uiid, \@xfwarnings
  (MSGID_EXIFTOOL_ERRORS)   => "  %i: %o\n",                    # error $uiid, \@xferrors
);

# invalid WPG metadata message IDs
use constant MSGID_WPGMD_DUPLICATE_OID   => "duplicate_oid";
use constant MSGID_WPGMD_UNDEF_ATTRS     => "undef_attrs";
use constant MSGID_WPGMD_INVALID_REGION  => "invalid_region";
use constant MSGID_WPGMD_INVALID_PERSON  => "invalid_person";
use constant MSGID_WPGMD_DUBIOUS_PERSON  => "dubious_person";
use constant MSGID_WPGMD_INVALID_TAG     => "invalid_tag";
use constant MSGID_WPGMD_DUBIOUS_TAG     => "dubious_tag";
use constant MSGID_WPGMD_INVALID_GEOTAG  => "invalid_geotag";
use constant MSGID_WPGMD_DUBIOUS_GEOTAG  => "dubious_geotag";
use constant MSGID_WPGMD_DUP_GEOTAG      => "dup_geotag";

# invalid WPG tag metadata message IDs
use constant MSGID_WPGTAG_DUP_ID         => "dup_tag_id";
use constant MSGID_WPGTAG_UNDEF_NAME     => "undef_tag_name";
use constant MSGID_WPGTAG_UNDEF_PID      => "undef_tag_pid";
use constant MSGID_WPGTAG_MISSING_PID    => "missing_tag_pid";
use constant MSGID_WPGTAG_MISSING_ROOT   => "missing_tag_root";

# invalid WPG people metadata message IDs
use constant MSGID_WPGPPL_DUP_ID         => "dup_people_id";
use constant MSGID_WPGPPL_UNDEF_NAME     => "undef_people_name";

my %ACTIONS = (
  'summary' => 1,
  'listerr' => 1,
  'dump'    => 1,
  'list'    => 1,
  'extract' => 1,
);

#{{{ auxilliary functions

sub error
{
  print STDERR ( @_, "\n" );
  exit( 1 );
}

sub usage
{
  print STDERR ( @_, "\n" );
  exit( 2 );
}

# convert the specified structure to a string
sub s2s
{
  local $Data::Dumper::Indent = 0;
  return Dumper( $_[0] );
}

# brush up the specified error message
sub bue
{
  my $error = $_[0];
  $error =~ s/^\s+//;
  $error =~ s/\s+$//;
  $error =~ s/\s+/ /g;
  $error =~ s/ at .*? line \d+\.$//;
  return lcfirst( $error );
}

#}}}

#{{{ cavmap

# converts and verifies the specified map
sub cavmap
{
  for my $me ( @_ ) {
    my $fn = "";
    if ( $me =~ /^s\{.*\}\{.*\}[a-z]*$/m ) {
      if ( ! defined( do { package _wpg2dk; eval( "\$fn =~ $me" ) } ) ) {
        usage( "Invalid map entry \"$me\" (", bue( $@ ), ")" );
      }
    }
    elsif ( $me =~ /^(.*?)(?:=(.*))?$/m ) {
      my ( $search, $repl ) = ( $1, $2 );
      $repl //= "";
      if ( ! defined( do { package _wpg2dk; eval( '$fn =~ s/$search/$repl/g' ) } ) ) {
        usage( "Invalid map entry \"$me\" (", bue( $@ ), ")" );
      }
      $me = [ $me, $search, $repl ];
    }
    else {
      usage( "Invalid map entry \"$me\"" );
    }
  }
}

#}}}

#{{{ aplmap

# applies the specified map to the specified file name
sub aplmap
{
  my $fn = shift( @_ );
  for my $me ( @_ ) {
    if ( ! ref( $me ) ) {
      if ( ! defined( do { package _wpg2dk; eval( "\$fn =~ $me" ) } ) ) {
        error( "Cannot apply map entry \"$me\" to \"$fn\" (", bue( $@ ), ")" );
      }
    }
    else {
      my ( $me, $search, $repl ) = @{$me};
      if ( ! defined( do { package _wpg2dk; eval( '$fn =~ s/$search/$repl/g' ) } ) ) {
        error( "Cannot apply map entry \"$me\" to \"$fn\" (", bue( $@ ), ")" );
      }
    }
  }
  return $fn;
}

#}}}

#{{{ catnodes, readtree

sub catnodes
{
  my ( $id, $nodes ) = @_;

  my $node = $nodes->{$id}->[0];
  if ( exists( $node->{'done'} ) ) {
    # no-op
  }
  elsif ( (! defined( $node->{'pid'} )) ) {
    $node->{'done'} = 1;
    push( @{$node->{'warnings'}},
          [ MSGID_WPGTAG_UNDEF_PID, $node ] );
  }
  elsif ( ($node->{'pid'} == 0) ) {
    $node->{'done'} = 1;
  }
  elsif ( (! exists( $nodes->{$node->{'pid'}} )) ) {
    $node->{'done'} = 1;
    push( @{$node->{'warnings'}},
          [ MSGID_WPGTAG_MISSING_PID, $node ] );
  }
  else {
    $node->{'done'} = 1;
    catnodes( $node->{'pid'}, $nodes );
    push( @{$nodes->{$id}}, @{$nodes->{$node->{'pid'}}} );
  }
}

# reads the tree of (geo)tags from the specified statement handle
# and returns it as a hash mapping tag ids to arrays consisting
# of tag nodes
#
#   {
#      <id> => [ <tag-node-0>, ..., <tag-node-n> ],
#      ...,
#   }
#
# where tag node 0 has tag id <id> and tag node i+1 is the parent
# node of tag node i.
sub readtree
{
  my ( $sth ) = @_;

  my %nodes = ();
  while ( my $node = $sth->fetchrow_hashref() ) {
    my $id = $node->{'id'};
    $node->{'warnings'} = [];

    if ( (! defined( $id )) || ($id == 0) ) {
      warn( "Cannot process undefined or zero node ID (", s2s( $node ), ")" );
      next;
    }

    if ( exists( $nodes{$id} ) ) {
      push( @{$nodes{$id}->[0]->{'warnings'}},
            [ MSGID_WPGTAG_DUP_ID, $node ] );
      next;
    }

    if ( (! defined( $node->{'name'} )) ||
         (length( $node->{'name'} ) == 0) ) {
      $node->{'name'} = "wpg2dk-generated-#$id";
      push( @{$node->{'warnings'}},
            [ MSGID_WPGTAG_UNDEF_NAME, $node ] );
    }

    $nodes{$id} = [ $node ];
  }

  # concatenate tag nodes along their path to root
  for my $id ( keys( %nodes ) ) {
    catnodes( $id, \%nodes );
  }

  # revert nodes
  for my $nodes ( values( %nodes ) ) {
    $nodes = [ reverse( @{$nodes} ) ];
  }

  # detect and flag rootless tag nodes (which can result from our
  # node loop detection)
  for my $nodes ( values( %nodes ) ) {
    if ( (defined( $nodes->[0]->{'pid'} )) &&
         ($nodes->[0]->{'pid'} != 0) ) {
      push( @{$nodes->[0]->{'warnings'}},
            [ MSGID_WPGTAG_MISSING_ROOT, $nodes->[0] ] );
    }
  }

  return \%nodes;
}

#}}}

#{{{ uiidmp

# returns whether the specified user interface ID matches the
# specified matchers
sub uiidmp
{
  my ( $uiid, $uiidms ) = @_;

  my $match = undef();
  if ( (scalar( @{$uiidms} ) == 0) || ($uiidms->[0] eq "-X") ) {
    $match = 1;
  }
  else {
    $match = 0;
  }

  my $inverted = 0;
  for my $uiidm ( @{$uiidms} ) {
    if ( ($uiidm eq "-X") && (! $inverted) ) {
      return 0 if ( ! $match );
      $inverted ^= 1;
    }
    elsif ( ($uiidm eq "-X") && ($inverted) ) {
      return 1 if ( $match );
      $inverted ^= 1;
    }
    elsif ( (! ref( $uiidm )) && ($uiid eq $uiidm) ) {
      $match = $inverted ? 0 : 1;
    }
    elsif ( (ref( $uiidm )) && ($uiid =~ /$uiidm/) ) {
      $match = $inverted ? 0 : 1;
    }
  }

  return $match;
}

#}}}

#{{{ object error handling

# media objects with warnings
my %warnobjs = ();

# hash that maps from message IDs to arrays of media objects
# having some warning message
my %warnids  = map { ($_ => []) } @MESSAGE_IDS;

# adds the specified warning to the specified media object and
# updates global variables on objects with warnings
sub addwarning
{
  my $obj     = shift( @_ );
  my $msgid   = shift( @_ );
  my $message = [ $msgid, @_ ];
  push( @{$obj->{'warnings'}}, $message );
  $warnobjs{$obj} = 1;
  push( @{$warnids{$msgid}}, $obj );
}

# media objects with errors
my %errobjs = ();

# hash that maps from message IDs to arrays of media objects
# having some error message
my %errids  = map { ($_ => []) } @MESSAGE_IDS;

# adds the specified error to the specified media object and
# updates global variables on erroneous objects
sub adderror
{
  my $obj     = shift( @_ );
  my $msgid   = shift( @_ );
  my $message = [ $msgid, @_ ];
  push( @{$obj->{'errors'}}, $message );
  $errobjs{$obj} = 1;
  push( @{$errids{$msgid}}, $obj );
}

# returns whether to continue processing the specified media
# object
sub continuep
{
  return scalar( @{$_[0]->{'errors'}} ) > 0 ? 0 : 1;
}

#}}}

#{{{ process commandline parameters

my $action = undef();
if ( scalar( @ARGV ) > 0 ) {
  $action = shift( @ARGV );
}
else {
  usage( "No action specified." );
}

if ( ! exists( $ACTIONS{$action} ) ) {
  usage( "Invalid action \"$action\" specified." );
}

# need to add commandline options (incomplete):
#
#   -pccl <people-completeness-color-label>
#   -geotagroot <geotag-root>
#   -geotags <structure-type>
#   -tags <structure-type>
#   -pl <pick-label>
my  $force  = 0;
my  @mmap   = ();
my  @xmap   = ();
my  $idtp   = "filename";
my  $errfmt = "structured";
{
  my $error = undef();
  local $SIG{'__WARN__'} = sub { $error = bue( $_[0] ) };
  if ( ! GetOptions( ($action eq "extract") ?
                     ("f|force"             => \$force) : (),
                      "m|mmap=s"            => \@mmap,
                      "x|xmap=s"            => \@xmap,
                      "i|idtype=s"          => \$idtp,
                     ($action eq "listerr") ?
                      ("e|error_format=s"   => \$errfmt) : () ) ) {
    usage( "Invalid commandline parameters specified ($error)." );
  }
}

# default XMP map
@xmap = 's{$}{.wpg2dk.xmp}' unless ( scalar( @xmap ) );

# convert and verify maps
cavmap( @mmap );
cavmap( @xmap );

# verify user interface ID type
if ( ($idtp ne "filename") &&
     ($idtp ne "oid") ) {
  usage( "Invalid user interface ID type \"$idtp\" specified." );
}

# verify error format
if ( ($errfmt ne "structured") &&
     ($errfmt ne "oneline") &&
     ($errfmt ne "short") ) {
  usage( "Invalid error format \"$errfmt\" specified." );
}

my $dbn = undef();
if ( scalar( @ARGV ) > 0 ) {
  $dbn = shift( @ARGV );
}
else {
  usage( "No database name specified." );
}
if ( ! -f $dbn ) {
  usage( "Invalid database name \"$dbn\" specified." );
}

# verify items, which can be:
# - message IDs for action "listerr"
# - UIID matchers for actions "dump", "list", "extract"
my @items = @ARGV;
if ( $action eq "listerr" ) {
  for my $msgid ( @items ) {
    if ( ! grep { $_ eq $msgid } @MESSAGE_IDS ) {
      usage( "Invalid message ID \"$msgid\" specified." );
    }
  }
}
elsif ( ($action eq "dump") ||
        ($action eq "list") ||
        ($action eq "extract") ) {
  my $prvnot = 0;
  for my $uiidm ( @items ) {
    if ( ($uiidm eq "-X") && (! $prvnot) ) {
      $prvnot = 1;
    }
    elsif ( ($uiidm eq "-X") && ($prvnot) ) {
      usage( "Invalid double negation in UIID matchers." );
    }
    else {
      $prvnot = 0;
    }

    if ( $uiidm =~ /^m\{(.*)\}$/m ) {
      my $uiidre = $1;
      if ( defined( $uiidre = do { package _wpg2dk; eval( 'qr{$uiidre}' ) } ) ) {
        $uiidm = $uiidre;
      }
      else {
        usage( "Invalid UIID matcher \"$uiidm\" (", bue( $@ ), ")" );
      }
    }
  }
  if ( $prvnot ) {
      usage( "Invalid trailing negation in UIID matchers." );
  }
}
elsif ( scalar( @ARGV ) > 0 ) {
  usage( "Extra commandline parameters @ARGV specified." );
}

#}}}

STDOUT->autoflush( 1 );
STDERR->autoflush( 1 );

my $exiftool = new Image::ExifTool();

my @errors   = ();
my @warnings = ();
$SIG{'__WARN__'} = sub { push( @warnings, $_[0] ) };

eval {

  my $dbh = DBI->connect( "dbi:SQLite:dbname=$dbn", undef(), undef(),
                          {
                            'sqlite_open_flags' => SQLITE_OPEN_READONLY,
                            'RaiseError'        => 1,
                          } );
  my $sth = undef();

#{{{ read media objects

  # read all media objects ...
  $sth = $dbh->prepare( q{
    select    o.objectid   oid,
              o.syncstatus status,
              o.title      title,
              o.rating     rating,
              o.flagged    flag,
              v.volumeid   volid,
              p.path       pn,
              o.filename   fn
    from      tblobject o
    left join tblpath   p on o.filepathid = p.pathid
    left join tblvolume v on p.volumeid   = v.volumeid
    order by  volid nulls first, pn nulls first, fn nulls first
  } );
  $sth->execute();

  # ... and store them in nearly-global structures, adding some
  # essential attributes on the way
  my %objs = ();
  my @objs = ();
  while ( my $obj = $sth->fetchrow_hashref() ) {
    # derive the user interface ID from the WPG metadata.  Be
    # relaxed with respect to undefined attributes, which we will
    # handle later.
    my $uiid = undef();
    if ( $idtp eq "oid" ) {
      $uiid = $obj->{'oid'} // "null";
    }
    else {
      $uiid = "#" . ($obj->{'volid'} // "null") .
                    catfile( split( /\\/, ($obj->{'pn'} || "null") ),
                             ($obj->{'fn'} || "null") );
      if ( -f (my $muiid = aplmap( $uiid, @mmap )) ) {
        $uiid = $muiid;
      }
    }
    $obj->{'uiid'}     = $uiid;

    $obj->{'errors'}   = [];
    $obj->{'warnings'} = [];

    $obj->{'people'}   = [];
    $obj->{'geotag'}   = undef();
    $obj->{'tags'}     = [];

    my $oid = $obj->{'oid'} || "null";
    if ( ! exists( $objs{$oid} ) ) {
      $objs{$oid} = [ $obj ];
    }
    elsif ( scalar( @{$objs{$oid}} ) == 1 ) {
      addwarning( $objs{$oid}->[0], MSGID_INVALID_WPGMD,
                                    MSGID_WPGMD_DUPLICATE_OID,
                                    $oid );
      addwarning( $obj, MSGID_INVALID_WPGMD,
                        MSGID_WPGMD_DUPLICATE_OID,
                        $oid );
      push( @{$objs{$oid}}, $obj );
    }
    else {
      addwarning( $obj, MSGID_INVALID_WPGMD,
                        MSGID_WPGMD_DUPLICATE_OID,
                        $oid );
      push( @{$objs{$oid}}, $obj );
    }
    push( @objs, $obj );
  }

  # handle undefined attributes, brush up others
  for my $obj ( @objs ) {
    if ( (defined( $obj->{'oid'} ))   &&
         (defined( $obj->{'volid'} )) &&
         (defined( $obj->{'pn'} ))    &&
         (length( $obj->{'pn'} ) > 0) &&
         (defined( $obj->{'fn'} ))    &&
         (length( $obj->{'fn'} ) > 0) ) {
      # no-op
    }
    else {
      addwarning( $obj, MSGID_INVALID_WPGMD,
                        MSGID_WPGMD_UNDEF_ATTRS,
                        undef() );
    }

    if ( (! defined( $obj->{'status'} )) ) {
      $obj->{'status'} = 0;
    }
    elsif ( ($obj->{'status'} & 2048) ) {
      $obj->{'status'} = 1;
    }
    else {
      $obj->{'status'} = 0;
    }
    if ( (defined( $obj->{'title'} )) &&
         ($obj->{'title'} eq "") ) {
      $obj->{'title'}  = undef()
    }
    $obj->{'rating'} //= 0;
    $obj->{'flag'}   //= 0;
  }

#}}}

#{{{ read persons and regions and attach them to media objects

  # read persons
  $sth = $dbh->prepare( q{
    select personid pid,
           name     name
    from   tblperson
  } );
  $sth->execute();
  my %persons = ();
  while ( my $person = $sth->fetchrow_hashref() ) {
    my $pid = $person->{'pid'};
    $person->{'warnings'} = [];

    if ( (! defined( $pid )) || ($pid == 0) ) {
      warn( "Cannot process undefined or invalid person ID of person (", s2s( $person ), ").\n" );
      next;
    }

    if ( exists( $persons{$pid} ) ) {
      push( @{$persons{$pid}->{'warnings'}},
            [ MSGID_WPGPPL_DUP_ID, $person ] );
      next;
    }

    if ( (! defined( $person->{'name'} )) ||
         (length( $person->{'name'} ) == 0) ) {
      $person->{'name'} = "wpg2dk-generated-#$pid";
      push( @{$person->{'warnings'}},
            [ MSGID_WPGPPL_UNDEF_NAME, $person ] );
    }

    $persons{$pid} = $person;
  }

  # read regions and attach them to objects.  Force lowercase
  # column names.
  $sth = $dbh->prepare( q{
    select objectid oid,
           personid pid,
           left     "left",
           top      top,
           width    width,
           height   height
    from   tblregion
  } );
  $sth->execute();
  while ( my $region = $sth->fetchrow_hashref() ) {
    my ( $oid, $pid ) = @{$region}{'oid', 'pid'};

    if ( (! defined( $oid )) ||
         (! exists( $objs{$oid} )) ) {
      warn( "Cannot process undefined or invalid object ID of region (", s2s( $region ), ").\n" );
    }
    elsif ( (! defined( $pid )) ||
            (! defined( $region->{'left'} ))  ||
            (! defined( $region->{'top'} ))   ||
            (! defined( $region->{'width'} )) ||
            (! defined( $region->{'height'} )) ) {
      addwarning( $_, MSGID_INVALID_WPGMD,
                      MSGID_WPGMD_INVALID_REGION,
                      $region ) for ( @{$objs{$oid}} );
    }
    elsif ( ($pid != 0) &&
            (! exists( $persons{$pid} )) ) {
      $region->{'name'} = "wpg2dk-generated-#$pid";
      push( @{$_->{'people'}}, $region ) for ( @{$objs{$oid}} );
      addwarning( $_, MSGID_INVALID_WPGMD,
                      MSGID_WPGMD_INVALID_PERSON,
                      $region ) for ( @{$objs{$oid}} );
    }
    elsif ( ($pid == 0) ) {
      $region->{'name'} = undef();
      push( @{$_->{'people'}}, $region ) for ( @{$objs{$oid}} );
    }
    else {
      $region->{'name'} = $persons{$pid}->{'name'};
      push( @{$_->{'people'}}, $region ) for ( @{$objs{$oid}} );
      if ( scalar( @{$persons{$pid}->{'warnings'}} ) > 0 ) {
        addwarning( $_, MSGID_INVALID_WPGMD,
                        MSGID_WPGMD_DUBIOUS_PERSON,
                        $persons{$pid} ) for ( @{$objs{$oid}} );
      }
    }
  }

#}}}

#{{{ read geotags and attach them to media objects

  # read geotags
  $sth = $dbh->prepare( q{
    select locationid       id,
           locationname     name,
           locationlat      lat,
           locationlong     long,
           locationparentid pid
    from   tbllocation
  } );
  $sth->execute();
  my $geotags = readtree( $sth );

  # attach geotags to objects
  $sth = $dbh->prepare( q{
    select locationid       id,
           objectid         oid
    from   tblocationUsage
  } );
  $sth->execute();
  while ( my @row = $sth->fetchrow_array() ) {
    my ( $id, $oid ) = @row;

    if ( (! defined( $oid )) ||
         (! exists( $objs{$oid} )) ) {
      warn( "Cannot process undefined or invalid object ID of geotag (", s2s( \@row ), ").\n" );
    }
    elsif ( (! defined( $id )) ||
            (! exists( $geotags->{$id} )) ) {
      addwarning( $_, MSGID_INVALID_WPGMD,
                      MSGID_WPGMD_INVALID_GEOTAG,
                      $id ) for ( @{$objs{$oid}} );
    }
    else {
      for my $obj ( @{$objs{$oid}} ) {
        if ( defined( $obj->{'geotag'} ) ) {
          addwarning( $obj, MSGID_INVALID_WPGMD,
                            MSGID_WPGMD_DUP_GEOTAG,
                            $geotags->{$id} );
        }
        else {
          $obj->{'geotag'} = $geotags->{$id};
          if ( grep( scalar( @{$_->{'warnings'}} ), @{$geotags->{$id}} ) ) {
            addwarning( $obj, MSGID_INVALID_WPGMD,
                              MSGID_WPGMD_DUBIOUS_GEOTAG,
                              $geotags->{$id} );
          }
        }
      }
    }
  }

#}}}

#{{{ read tags and attach them to media objects

  # read tags
  $sth = $dbh->prepare( q{
    select labelid       id,
           labelname     name,
           parentlabelid pid
    from   tbllabel
  } );
  $sth->execute();
  my $tags = readtree( $sth );

  # attach tags to objects
  $sth = $dbh->prepare( q{
    select labelid       id,
           objectid      oid
    from   tbllabelusage
  } );
  $sth->execute();
  while ( my @row = $sth->fetchrow_array() ) {
    my ( $id, $oid ) = @row;

    if ( (! defined( $oid )) ||
         (! exists( $objs{$oid} )) ) {
      warn( "Cannot process undefined or invalid object ID of tag (", s2s( \@row ), ").\n" );
    }
    elsif ( (! defined( $id )) ||
            (! exists( $tags->{$id} )) ) {
      addwarning( $_, MSGID_INVALID_WPGMD,
                      MSGID_WPGMD_INVALID_TAG,
                      $id ) for ( @{$objs{$oid}} );
    }
    else {
      push( @{$_->{'tags'}}, $tags->{$id} ) for ( @{$objs{$oid}} );
      if ( grep( scalar( @{$_->{'warnings'}} ), @{$tags->{$id}} ) ) {
        addwarning( $_, MSGID_INVALID_WPGMD,
                        MSGID_WPGMD_DUBIOUS_TAG,
                        $tags->{$id} ) for ( @{$objs{$oid}} );
      }
    }
  }

#}}}

#{{{ post-process media objects

  # check whether we have metadata worth extracting
  for my $obj ( @objs ) {
    if ( continuep( $obj ) ) {
      # probably consider "status" only if option "-pccl" has
      # been specified (incomplete)
      if ( ($obj->{'status'} == 0)         &&
           (! defined( $obj->{'title'} ))  &&
           ($obj->{'rating'} == 0)         &&
           ($obj->{'flag'} == 0)           &&
           (@{$obj->{'people'}} == 0)      &&
           (! defined( $obj->{'geotag'} )) &&
           (@{$obj->{'tags'}} == 0) ) {
        adderror( $obj, MSGID_NO_WPGMD );
      }
    }
  }

  # map file names and look up media metadata
  my %fns = ();
  my %xns = ();
  for my $obj ( @objs ) {
    if ( continuep( $obj ) ) {
      # determine original (aka. pseudo) and mapped media file
      # name
      my $fno = "#" . ($obj->{'volid'} // "null") .
                      catfile( split( /\\/, ($obj->{'pn'} || "null") ),
                               ($obj->{'fn'} || "null") );
      my $fn  = aplmap( $fno, @mmap );

      # likewise for the intermediate XMP file name
      my $xno = $fn;
      my $xn  = aplmap( $fn, @xmap );

      $obj->{'fno'} = $fno;
      $obj->{'fn'}  = $fn;
      $obj->{'xno'} = $xno;
      $obj->{'xn'}  = $xn;

      if ( length( $fn ) == 0 ) {
        adderror( $obj, MSGID_IGNORED_FILE, $fno );
      }
      elsif ( $fn eq $fno ) {
        adderror( $obj, MSGID_UNMAPPED_FILE, $fno );
      }
      elsif ( ! -f $fn ) {
        adderror( $obj, MSGID_MISSING_FILE, $fno, $fn );
      }
      elsif ( ! exists( $fns{$fn} ) ) {
        $fns{$fn} = [ $obj ];
      }
      elsif ( scalar( @{$fns{$fn}} ) == 1 ) {
        adderror( $fns{$fn}->[0], MSGID_DUPLICATE_FILE,
                                  $fns{$fn}->[0]->{'fno'}, $fn );
        adderror( $obj, MSGID_DUPLICATE_FILE, $fno, $fn );
        push( @{$fns{$fn}}, $obj );
      }
      else {
        adderror( $obj, MSGID_DUPLICATE_FILE, $fno, $fn );
        push( @{$fns{$fn}}, $obj );
      }
    }

    if ( continuep( $obj ) ) {
      my $xno = $obj->{'xno'};
      my $xn  = $obj->{'xn'};

      if ( length( $xn ) == 0 ) {
        adderror( $obj, MSGID_IGNORED_XFILE, $xno );
      }
      elsif ( $xn eq $xno ) {
        adderror( $obj, MSGID_UNMAPPED_XFILE, $xno );
      }
      elsif ( (-e $xn) && (! $force) ) {
        adderror( $obj, MSGID_EXISTING_XFILE, $xno, $xn );
      }
      elsif ( ! exists( $xns{$xn} ) ) {
        $xns{$xn} = [ $obj ];
      }
      elsif ( scalar( @{$xns{$xn}} ) == 1 ) {
        adderror( $xns{$xn}->[0], MSGID_DUPLICATE_XFILE,
                                  $xns{$xn}->[0]->{'xno'}, $xn );
        adderror( $obj, MSGID_DUPLICATE_FILE, $xno, $xn );
        push( @{$xns{$xn}}, $obj );
      }
      else {
        adderror( $obj, MSGID_DUPLICATE_XFILE, $xno, $xn );
        push( @{$xns{$xn}}, $obj );
      }
    }

    if ( continuep( $obj ) ) {
      my $fn = $obj->{'fn'};

      # determine media file metadata
      my $info = $exiftool->ImageInfo( $fn,
                                       [ 'File::MimeType',
                                         'EXIF:Orientation',
                                         'ExifTool:Warning',
                                         'ExifTool:Error' ],
                                       { 'PrintConv' => 0 } );

      $obj->{'mime'}   = $info->{'MIMEType'};
      $obj->{'xfornt'} = $info->{'Orientation'};

      # convert ExifTool warnings and errors into media object
      # warnings and errors, respectively
      my @xfwarnings = ();
      my @xferrors   = ();
      for my $tag ( sort( keys( %{$info} ) ) ) {
        next if ( ($tag =~ /^Warning\b/) &&
                  (defined( $info->{$tag} )) &&
                  (lc( $info->{$tag}) eq "[minor] fixed incorrect uri for xmlns:microsoftphoto") );
        push( @xfwarnings, bue( $info->{$tag} ) ) if ( $tag =~ /^Warning\b/ );
        push( @xferrors,   bue( $info->{$tag} ) ) if ( $tag =~ /^Error\b/ );
      }
      if ( scalar( @xfwarnings ) > 0 ) {
        addwarning( $obj, MSGID_EXIFTOOL_WARNINGS, \@xfwarnings );
      }
      if ( scalar( @xferrors ) > 0 ) {
        adderror( $obj, MSGID_EXIFTOOL_ERRORS, \@xferrors );
      }
    }
  }

#}}}

  # determine number of media objects, with errors, without
  # errors but with warnings, without any issues
  my $totobjc = scalar( @objs );
  my $errobjc = scalar( keys( %errobjs ) );
  my $wrnobjc = 0;
  for my $objkey ( keys( %warnobjs ) ) {
    $wrnobjc++ if ( ! exists( $errobjs{$objkey} ) );
  }
  my $okobjc  = $totobjc - $errobjc - $wrnobjc;

#{{{ action "summary"

  if ( $action eq "summary" ) {
    print(  "Media object counts:\n" );
    print(  "\n" );
    printf( "  total                %6d\n", $totobjc );
    printf( "  with errors          %6d\n", $errobjc );
    printf( "  with warnings        %6d\n", $wrnobjc );
    printf( "  without any issues   %6d\n", $okobjc );

    if ( $errobjc > 0 ) {
    print(  "\n" );
    print(  "Media object counts by error category.  Objects having\n" );
    print(  "errors with different categories are counted more than once.\n" );
    print(  "\n" );
    for my $msgid ( @MESSAGE_IDS ) {
    if ( scalar( @{$errids{$msgid}} ) > 0 ) {
    printf( "  %-20s %6d\n", $msgid, scalar( @{$errids{$msgid}} ) );
    }
    }
    }

    if ( $wrnobjc > 0 ) {
    print(  "\n" );
    print(  "Media object counts by warning category.  Objects having errors\n" );
    print(  "are not counted here.  Objects having warnings with different\n" );
    print(  "categories are counted more than once.\n" );
    print(  "\n" );
    for my $msgid ( @MESSAGE_IDS ) {
    if ( scalar( @{$warnids{$msgid}} ) > 0 ) {
    printf( "  %-20s %6d\n", $msgid, scalar( @{$warnids{$msgid}} ) );
    }
    }
    }

    if ( ($errobjc > 0) || ($wrnobjc > 0) ) {
    print(  "\n" );
    print(  "Use command \"listerr\" to list objects with errors or warnings.\n" );
    }
  }

#}}}

#{{{ action "listerr"

  elsif ( $action eq "listerr" ) {
    my @msgids = (scalar( @items ) > 0) ? @items : @MESSAGE_IDS;

    for my $msgid ( @msgids ) {
      if ( (scalar( @{$warnids{$msgid}} ) > 0) ||
           (scalar( @{$errids{$msgid}} ) > 0) ) {
        print( "$msgid\n" ) if ( $errfmt eq "structured" );
        for my $obj ( @{$warnids{$msgid}}, @{$errids{$msgid}} ) {
          for my $error ( grep { $_->[0] eq $msgid }
                               @{$obj->{'warnings'}},
                               @{$obj->{'errors'}} ) {
            my $uiid = $obj->{'uiid'};
            my ( undef(), @msgprms ) = @{$error};
            my $msgfmt = $MESSAGE_FORMATS{$msgid};

            # process "%i" placeholders (only allowed at the
            # beginning of the format)
            if ( $msgfmt =~ s/^( *)%i/$1%s/ ) {
              unshift( @msgprms, $uiid );
            }

            # process "%o" placeholders (only allowed at the end
            # of the format) and remember indentation
            my $indent = "";
            if ( $msgfmt =~ s/^( +)(.*)%o$/$1$2%s/s ) {
              $indent = $1;
            }

            if ( $errfmt eq "structured" ) {
              printf( $msgfmt,
                      map { ! defined( $_ ) ? "undef" :
                            ! ref( $_ ) ? $_ :
                            do { my $s = Dumper( $_ ); chomp( $s );
                                 $s =~ s/\n/\n$indent/g; $s } }
                      @msgprms );
            }
            elsif ( $errfmt eq "oneline" ) {
              $msgfmt =~ s/\s+(?=\S)//g;
              printf( "$msgid:$msgfmt",
                      map { ! defined( $_ ) ? "undef" :
                            ! ref( $_ ) ? $_ : s2s( $_ ) }
                      @msgprms );
            }
            else {
              print( "$msgid:$uiid\n" );
            }
          }
        }
      }
    }
  }

#}}}

#{{{ actions "dump", "list", "extract"

  else {
    # same as above, limited to the current action execution
    my $totobjca = 0;
    my $errobjca = 0;
    my $wrnobjca = 0;
    my $okobjca  = 0;

    for my $obj ( @objs ) {
      if ( (uiidmp( $obj->{'uiid'}, \@items )) ) {
        # update counters
        $totobjca++;
        if ( exists( $errobjs{$obj} ) ) {
          $errobjca++;
        }
        elsif ( exists( $warnobjs{$obj} ) ) {
          $wrnobjca++;
        }
        else {
          $okobjca++;
        }

        # process action
        if ( ($action eq "dump") ) {
          print( Dumper( $obj ) );
        }
        elsif ( ($action eq "list") && (continuep( $obj )) ) {
          print( $obj->{'uiid'}, "\n" );
        }
        elsif ( ($action eq "extract") && (continuep( $obj )) ) {
        }
      }
    }

    print  STDERR ( "\n" );
    print  STDERR ( "Media objects:\n" );
    printf STDERR ( "Total:    %6d, with errors: %5d, with warnings: %5d, OK: %5d\n",
                    $totobjc, $errobjc, $wrnobjc, $okobjc );
    printf STDERR ( "Selected: %6d, with errors: %5d, with warnings: %5d, OK: %5d\n",
                    $totobjca, $errobjca, $wrnobjca, $okobjca );
    if ( $action ne "dump" ) {
    print  STDERR ( "Media objects with errors not processed.\n" );
    }
  }

#}}}

};
if ( $@ ) {
  push( @errors, $@ );
}

#{{{ handle global warnings and errors

if ( scalar( @warnings ) > 0 ) {
  print STDERR ( "\n" );
  print STDERR ( "Global warnings:\n" );
  print STDERR ( $_ ) for ( @warnings );
}

if ( scalar( @errors ) > 0 ) {
  print STDERR ( "\n" );
  print STDERR ( "Global errors:\n" );
  print STDERR ( $_ ) for ( @errors );
}

if ( scalar( @errors ) == 0 ) {
  exit( 0 );
}
else {
  exit( 1 );
}

#}}}
